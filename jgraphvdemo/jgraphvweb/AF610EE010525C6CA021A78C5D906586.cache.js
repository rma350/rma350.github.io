jgraphvweb.onScriptDownloaded(["var $wnd = $wnd || window.parent;\nvar __gwtModuleFunction = $wnd.jgraphvweb;\nvar $sendStats = __gwtModuleFunction.__sendStats;\n$sendStats('moduleStartup', 'moduleEvalStart');\nvar $gwt_version = \"2.6.0\";\nvar $strongName = 'AF610EE010525C6CA021A78C5D906586';\nvar $doc = $wnd.document;function __gwtStartLoadingFragment(frag) {\nvar fragFile = 'deferredjs/' + $strongName + '/' + frag + '.cache.js';\nreturn __gwtModuleFunction.__startLoadingFragment(fragFile);\n}\nfunction __gwtInstallCode(code) {return __gwtModuleFunction.__installRunAsyncCode(code);}\nvar $stats = $wnd.__gwtStatsEvent ? function(a) {return $wnd.__gwtStatsEvent(a);} : null;\nvar $sessionId = $wnd.__gwtStatsSessionId ? $wnd.__gwtStatsSessionId : null;\nvar _, P0_longLit = {l:0, m:0, h:0}, Pfa0_longLit = {l:4000, m:0, h:0}, seedTable = {}, Q$Object = 0, Q$String = 1, Q$Animation = 2, Q$Demo = 3, Q$NodePositions$NodeData = 4, Q$InternalEdge = 5, Q$Edge = 6, Q$Node = 7, Q$CooperativeTask = 8, Q$SynchronousTaskRunner$TaskEntry = 9, Q$Drawable = 10, Q$NativeShapeBuffer$BufferUsage = 11, Q$JavaScriptException = 12, Q$SerializableThrowable = 13, Q$Style$HasCssName = 14, Q$Style$TextAlign = 15, Q$HasDirection$Direction = 16, Q$LongLibBase$LongEmul = 17, Q$HtmlLogFormatter = 18, Q$EventListener = 19, Q$Serializable = 20, Q$Boolean = 21, Q$CharSequence = 22, Q$Comparable = 23, Q$Enum = 24, Q$Float = 25, Q$Integer = 26, Q$Number = 27, Q$Object_$1 = 28, Q$StackTraceElement = 29, Q$Throwable = 30, Q$Date = 31, Q$List = 32, Q$Map = 33, Q$Map$Entry = 34, Q$RandomAccess = 35, Q$Set = 36, Q$Handler = 37, Q$Handler_$1 = 38, Q$Logger = 39, CM$ = {};\nfunction newSeed(id_0){\n  return new seedTable[id_0];\n}\n\nfunction defineSeed(id_0, superSeed, castableTypeMap){\n  var seed = seedTable[id_0];\n  if (seed && !seed.___clazz$) {\n    _ = seed.prototype;\n  }\n   else {\n    !seed && (seed = seedTable[id_0] = function(){\n    }\n    );\n    _ = seed.prototype = superSeed < 0?{}:newSeed(superSeed);\n    _.castableTypeMap$ = castableTypeMap;\n  }\n  for (var i = 3; i < arguments.length; ++i) {\n    arguments[i].prototype = _;\n  }\n  if (seed.___clazz$) {\n    _.___clazz$ = seed.___clazz$;\n    seed.___clazz$ = null;\n  }\n}\n\nfunction makeCastMap(a){\n  var result = {};\n  for (var i = 0, c = a.length; i < c; ++i) {\n    result[a[i]] = 1;\n  }\n  return result;\n}\n\nfunction nullMethod(){\n}\n\nfunction Object_1(){\n}\n\ndefineSeed(1, -1, CM$, Object_1);\n_.equals$ = function equals(other){\n  return this === other;\n}\n;\n_.getClass$ = function getClass_0(){\n  return this.___clazz$;\n}\n;\n_.hashCode$ = function hashCode_0(){\n  return getHashCode(this);\n}\n;\n_.toString$ = function toString_0(){\n  return this.___clazz$.typeName + '@' + toPowerOfTwoString(this.hashCode$());\n}\n;\n_.toString = function(){\n  return this.toString$();\n}\n;\n_.typeMarker$ = nullMethod;\nfunction lerp(lowerBound, upperBound, t){\n  return (1 - t) * lowerBound + t * upperBound;\n}\n\nfunction allDemos(){\n  var ans;\n  ans = new ArrayList_0;\n  $add_1(ans, new ArcDemo_0);\n  $add_1(ans, new ConnectTwoPointsDemo_0);\n  $add_1(ans, new DirectedGeometricGraph_0);\n  $add_1(ans, new ForceDirectedErdosRenyiDemo_0);\n  $add_1(ans, new GraphArcDemo_0);\n  $add_1(ans, new RandomCirclesDemo_0);\n  $add_1(ans, new TwoPointsDemo_0);\n  $add_1(ans, new UndirectedGeometricGraph_0);\n  return ans;\n}\n\nfunction $addIntParam(this$static, initValue){\n  var ans;\n  ans = new Demo$IntParam_0(initValue);\n  $add_1(this$static.intParams, ans);\n  return ans;\n}\n\nfunction Demo_0(name_0){\n  this.name_0 = name_0;\n  this.intParams = new ArrayList_0;\n  new ArrayList_0;\n  new ArrayList_0;\n}\n\ndefineSeed(6, 1, makeCastMap([Q$Demo]));\nfunction ArcDemo_0(){\n  Demo_0.call(this, 'Arc demo');\n  this.arcWidth = new Demo$FloatParam_0(3);\n}\n\ndefineSeed(5, 6, makeCastMap([Q$Demo]), ArcDemo_0);\n_.setup = function setup(engine){\n  var arcBuilder, arcs, arcsBuffer, bufferBuilder, points;\n  arcBuilder = new ArcBuilder_0(engine.gl);\n  $set(arcBuilder.iFrom, 10, 20);\n  $set(arcBuilder.iTo, 100, 20);\n  arcBuilder.iArcWidth = dynamicCast(this.arcWidth.value_0, Q$Float).value_0;\n  $computeArc(arcBuilder);\n  bufferBuilder = new ArcBufferBuilder_0;\n  $ensureCapacity(bufferBuilder, bufferBuilder.sizeInFloats + ($clinit_ArcMemLayout() , FLOATS_PER_ARC_TRIANGLE));\n  writeArcTriangle_0(bufferBuilder.buffer, bufferBuilder.sizeInFloats, arcBuilder);\n  bufferBuilder.sizeInFloats += FLOATS_PER_ARC_TRIANGLE;\n  arcsBuffer = new ArcBuffer_1(engine.gl, bufferBuilder, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  arcs = new Arcs_0(engine.camera, engine.arcShader, arcsBuffer);\n  $addToScene(engine.scene, arcs);\n  points = new PointsBuffer_0(engine.gl, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [10, 20, 10, 100, 20, 10]), STATIC);\n  $addToScene(engine.scene, new Points_0(engine.camera, engine.pointsShader, points));\n}\n;\nfunction ConnectTwoPointsDemo_0(){\n  Demo_0.call(this, 'Connect two points');\n  this.arrowHeads = new Demo$BooleanParam_0;\n}\n\ndefineSeed(7, 6, makeCastMap([Q$Demo]), ConnectTwoPointsDemo_0);\n_.setup = function setup_0(engine){\n  var arrowBuffer, buffer, circleBuffer, circles, circs, directedLines, lineData, lines;\n  engine.gl;\n  if (dynamicCast(this.arrowHeads.value_0, Q$Boolean).value_0) {\n    arrowBuffer = new DirectedArrowBuffer_0(engine.gl, 2, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n    $setArrow_0(arrowBuffer, 0, new JVec2_1(10, 20), new JVec2_1(400, 200), 5, 15, 30, 10, 30);\n    $setArrow_0(arrowBuffer, 1, new JVec2_1(200, 400), new JVec2_1(400, 200), 5, 15, 30, 15, 30);\n    $checkedPutShapes(arrowBuffer.triangleBuffer, arrowBuffer.buffer);\n    directedLines = new DirectedLines_0(engine.camera, engine.triangleShader, arrowBuffer.triangleBuffer);\n    $addToScene(engine.scene, directedLines);\n  }\n   else {\n    lineData = new LinesBuffer_0(engine.gl, 2, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n    buffer = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 8, 1));\n    setLine(buffer, 0, 10, 20, 400, 200);\n    setLine(buffer, 1, 200, 400, 400, 200);\n    $validateFloatAlignment(lineData, buffer.length);\n    $putAll(lineData.vertexBuffer, buffer);\n    lines = new Lines_0(engine.camera, engine.linesShader, lineData, 10);\n    $addToScene(engine.scene, lines);\n  }\n  circles = new CirclesBuffer_0(engine.gl, 3, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  circleBuffer = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 72, 1));\n  setCircle(circleBuffer, 0, 10, 20, 10);\n  setCircle(circleBuffer, 1, 200, 400, 15);\n  setCircle(circleBuffer, 2, 400, 200, 30);\n  $validateFloatAlignment(circles, circleBuffer.length);\n  $putAll(circles.vertexBuffer, circleBuffer);\n  circs = new Circles_0(engine.camera, engine.circlesShader, circles);\n  $addToScene(engine.scene, circs);\n}\n;\nfunction Demo$Param_0(initValue){\n  this.value_0 = initValue;\n}\n\ndefineSeed(9, 1, {});\nfunction Demo$BooleanParam_0(){\n  Demo$Param_0.call(this, ($clinit_Boolean() , $clinit_Boolean() , TRUE));\n}\n\ndefineSeed(8, 9, {}, Demo$BooleanParam_0);\nfunction Demo$FloatParam_0(initValue){\n  Demo$Param_0.call(this, new Float_0(initValue));\n}\n\ndefineSeed(10, 9, {}, Demo$FloatParam_0);\nfunction Demo$IntParam_0(initValue){\n  Demo$Param_0.call(this, valueOf(initValue));\n}\n\ndefineSeed(11, 9, {}, Demo$IntParam_0);\nfunction DirectedGeometricGraph_0(){\n  Demo_0.call(this, 'Directed Geometric Graph');\n  this.numNodes = new Demo$IntParam_0(500);\n  this.nodeSize = new Demo$FloatParam_0(10);\n  this.minDistForEdge = new Demo$FloatParam_0(100);\n}\n\ndefineSeed(12, 6, makeCastMap([Q$Demo]), DirectedGeometricGraph_0);\n_.setup = function setup_1(engine){\n  var graph, maxPos, minPos, nodes, view;\n  engine.gl;\n  minPos = new JVec2_1(0, 0);\n  maxPos = new JVec2_1(2000, 2000);\n  nodes = randomPositionNodes(dynamicCast(this.numNodes.value_0, Q$Integer).value_0, minPos, maxPos, dynamicCast(this.nodeSize.value_0, Q$Float).value_0);\n  graph = generateDirectedGeometricGraph(nodes, dynamicCast(this.minDistForEdge.value_0, Q$Float).value_0);\n  view = directedView(graph, engine, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  $addToScene(engine.scene, view);\n}\n;\nfunction ForceDirectedErdosRenyiDemo_0(){\n  Demo_0.call(this, 'Force Directed Erdos Renyi Graph');\n  this.numNodes = $addIntParam(this, 50);\n}\n\ndefineSeed(13, 6, makeCastMap([Q$Demo]), ForceDirectedErdosRenyiDemo_0);\n_.setup = function setup_2(engine){\n  var animation, edgeProbability, graph, input_0, layout, view;\n  edgeProbability = 3 / dynamicCast(this.numNodes.value_0, Q$Integer).value_0;\n  graph = generateErdosRenyiGraph(dynamicCast(this.numNodes.value_0, Q$Integer).value_0, edgeProbability, engine.gl);\n  view = simpleView(graph, engine, ($clinit_NativeShapeBuffer$BufferUsage() , DYNAMIC));\n  $addToScene(engine.scene, view);\n  input_0 = new LayoutInput_0(graph.adjacency);\n  layout = new SpringLayout_0(input_0, engine.gl);\n  animation = new AnimatedGraphLayout_0((engine.gl , view));\n  $addAnimation(engine.scene, animation);\n  $submit(engine.taskRunner, layout, animation.coopListener);\n}\n;\nfunction GraphArcDemo_0(){\n  Demo_0.call(this, 'Graph Arc Demo');\n  this.numNodes = new Demo$IntParam_0(500);\n  this.nodeSize = new Demo$FloatParam_0(10);\n  this.minDistForEdge = new Demo$FloatParam_0(100);\n}\n\ndefineSeed(14, 6, makeCastMap([Q$Demo]), GraphArcDemo_0);\n_.setup = function setup_3(engine){\n  var graph, maxPos, minPos, nodes, view;\n  engine.gl;\n  minPos = new JVec2_1(0, 0);\n  maxPos = new JVec2_1(2000, 2000);\n  nodes = randomPositionNodes(dynamicCast(this.numNodes.value_0, Q$Integer).value_0, minPos, maxPos, dynamicCast(this.nodeSize.value_0, Q$Float).value_0);\n  graph = generateUndirectedGeometricGraph(nodes, dynamicCast(this.minDistForEdge.value_0, Q$Float).value_0);\n  view = arcView(graph, engine, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  $addToScene(engine.scene, view);\n}\n;\nfunction RandomCirclesDemo_0(){\n  Demo_0.call(this, 'Random Circles');\n  this.numCirclesParam = $addIntParam(this, 1000);\n}\n\ndefineSeed(15, 6, makeCastMap([Q$Demo]), RandomCirclesDemo_0);\n_.setup = function setup_4(engine){\n  var buffer, circles, circs, i, numCircles;\n  numCircles = dynamicCast(this.numCirclesParam.value_0, Q$Integer).value_0;\n  circles = new CirclesBuffer_0(engine.gl, numCircles, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  buffer = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, numCircles * 6 * 4, 1));\n  for (i = 0; i < numCircles; i++) {\n    setCircle(buffer, i, random() * 2000, random() * 2000, random() * 20);\n  }\n  $validateFloatAlignment(circles, buffer.length);\n  $putAll(circles.vertexBuffer, buffer);\n  circs = new Circles_0(engine.camera, engine.circlesShader, circles);\n  $addToScene(engine.scene, circs);\n}\n;\nfunction TwoPointsDemo_0(){\n  Demo_0.call(this, 'Two points');\n}\n\ndefineSeed(16, 6, makeCastMap([Q$Demo]), TwoPointsDemo_0);\n_.setup = function setup_5(engine){\n  var points;\n  points = new PointsBuffer_0(engine.gl, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [10, 20, 10, 400, 200, 15]), ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  $addToScene(engine.scene, new Points_0(engine.camera, engine.pointsShader, points));\n}\n;\nfunction UndirectedGeometricGraph_0(){\n  Demo_0.call(this, 'Undirected Geometric Graph');\n  this.numNodes = new Demo$IntParam_0(500);\n  this.nodeSize = new Demo$FloatParam_0(10);\n  this.minDistForEdge = new Demo$FloatParam_0(100);\n}\n\ndefineSeed(17, 6, makeCastMap([Q$Demo]), UndirectedGeometricGraph_0);\n_.setup = function setup_6(engine){\n  var graph, maxPos, minPos, nodes, view;\n  engine.gl;\n  minPos = new JVec2_1(0, 0);\n  maxPos = new JVec2_1(2000, 2000);\n  nodes = randomPositionNodes(dynamicCast(this.numNodes.value_0, Q$Integer).value_0, minPos, maxPos, dynamicCast(this.nodeSize.value_0, Q$Float).value_0);\n  graph = generateUndirectedGeometricGraph(nodes, dynamicCast(this.minDistForEdge.value_0, Q$Float).value_0);\n  view = simpleView(graph, engine, ($clinit_NativeShapeBuffer$BufferUsage() , STATIC));\n  $addToScene(engine.scene, view);\n}\n;\nfunction $moveTo(this$static, screenCenterX, screenCenterY){\n  var newBLX, newBLY, newWorldBLX, newWorldBLY, newWorldCenterX, newWorldCenterY, worldNewBL, worldNewCenter;\n  newBLX = screenCenterX - ~~(this$static.screenWidthPx / 2);\n  newBLY = screenCenterY - ~~(this$static.screenHeightPx / 2);\n  ($clinit_System() , out_0).println('Moving to screen coords (x,y): ' + screenCenterX + ', ' + screenCenterY);\n  worldNewCenter = nMult(nInvert(this$static.view), nCreateVec4(screenCenterX, screenCenterY, 0, 1));\n  newWorldCenterX = worldNewCenter[0];\n  newWorldCenterY = worldNewCenter[1];\n  out_0.println('Moving to world coords center (x,y): ' + newWorldCenterX + ', ' + newWorldCenterY);\n  worldNewBL = nMult(nInvert(this$static.view), nCreateVec4(newBLX, newBLY, 0, 1));\n  newWorldBLX = worldNewBL[0];\n  newWorldBLY = worldNewBL[1];\n  out_0.println('Moving to world coords bottom left (x,y): ' + newWorldBLX + ', ' + newWorldBLY);\n  $moveWorldBLTo(this$static, newWorldBLX, newWorldBLY);\n}\n\nfunction $moveWorldBLTo(this$static, x_0, y_0){\n  nSetIdentity(this$static.view);\n  nScale(this$static.view, this$static.zoomLevel, this$static.zoomLevel);\n  nTranslate(this$static.view, -x_0, -y_0);\n  this$static.viewBLX = x_0;\n  this$static.viewBLY = y_0;\n}\n\nfunction $setViewport(this$static, width_0, height){\n  nSetOrtho2D(this$static.projection, 0, width_0, 0, height);\n  this$static.screenWidthPx = width_0;\n  this$static.screenHeightPx = height;\n}\n\nfunction $translateBy(this$static, screenDx, screenDy){\n  var worldDistMv;\n  worldDistMv = nMult(nInvert(this$static.view), nCreateVec4(screenDx, screenDy, 0, 0));\n  $moveWorldBLTo(this$static, this$static.viewBLX + worldDistMv[0], this$static.viewBLY + worldDistMv[1]);\n}\n\nfunction $zoom(this$static, scaleFactor, zoomAboutX, zoomAboutY){\n  var tx, ty, worldZoomPoint;\n  worldZoomPoint = nMult(nInvert(this$static.view), nCreateVec4(zoomAboutX, zoomAboutY, 0, 1));\n  this$static.zoomLevel *= scaleFactor;\n  tx = zoomAboutX / this$static.zoomLevel - worldZoomPoint[0];\n  ty = zoomAboutY / this$static.zoomLevel - worldZoomPoint[1];\n  $moveWorldBLTo(this$static, -tx, -ty);\n}\n\nfunction Camera_0(){\n  this.projection = nCreateMat4();\n  nSetIdentity(this.projection);\n  this.view = nCreateMat4();\n  nSetIdentity(this.view);\n  this.viewBLX = 0;\n  this.viewBLY = 0;\n  this.zoomLevel = 1;\n}\n\ndefineSeed(18, 1, {}, Camera_0);\n_.screenHeightPx = 0;\n_.screenWidthPx = 0;\n_.viewBLX = 0;\n_.viewBLY = 0;\n_.zoomLevel = 0;\nfunction $drawFrame(this$static){\n  $glClear(this$static.gl, this$static.gl.gl.COLOR_BUFFER_BIT);\n  $draw(this$static.scene);\n}\n\nfunction $onResize(this$static, width_0, height){\n  $glViewport(this$static.gl, width_0, height);\n  $setViewport(this$static.camera, width_0, height);\n}\n\nfunction $reset(this$static){\n  $cancelAll(this$static.taskRunner);\n  $clear(this$static.scene);\n}\n\nfunction $update(this$static, ellapsedMs){\n  $update_4(this$static.taskRunner);\n  $update_0(this$static.scene, ellapsedMs);\n}\n\nfunction $zoom_0(this$static, scaleFactor, screenCenterX, screenCenterY){\n  $zoom(this$static.camera, scaleFactor, screenCenterX, screenCenterY);\n}\n\nfunction Engine_0(gl, taskRunner){\n  this.gl = gl;\n  this.taskRunner = taskRunner;\n  gl.gl.clearColor(1, 1, 1, 1);\n  $glEnable(gl, gl.gl.BLEND);\n  $glBlendFunc(gl, gl.gl.SRC_ALPHA, gl.gl.ONE_MINUS_SRC_ALPHA);\n  this.camera = new Camera_0(gl);\n  this.pointsShader = new PointsShader_0(gl);\n  this.circlesShader = new CirclesShader_0(gl);\n  this.linesShader = new LinesShader_0(gl);\n  this.triangleShader = new TriangleShader_0(gl);\n  this.arcShader = new ArcShader_0(gl);\n  this.scene = new Scene_0;\n}\n\ndefineSeed(19, 1, {}, Engine_0);\nfunction $addAnimation(this$static, animation){\n  $add_2(this$static.animations, animation);\n}\n\nfunction $addToScene(this$static, drawable){\n  $add_1(this$static.drawables, drawable);\n}\n\nfunction $clear(this$static){\n  $clear_0(this$static.drawables);\n  $clearImpl(this$static.animations.map_0);\n}\n\nfunction $draw(this$static){\n  var drawable, drawable$iterator;\n  for (drawable$iterator = new AbstractList$IteratorImpl_0(this$static.drawables); drawable$iterator.i < drawable$iterator.this$0.size_0;) {\n    drawable = dynamicCast($next_0(drawable$iterator), Q$Drawable);\n    drawable.draw();\n  }\n}\n\nfunction $update_0(this$static, ellapsedMs){\n  var it, nextAnim;\n  it = $iterator($keySet(this$static.animations.map_0));\n  while ($hasNext(it.val$outerIter.iter)) {\n    nextAnim = dynamicCast($next_1(it), Q$Animation);\n    $update_1(nextAnim, ellapsedMs) && $remove_0(it.val$outerIter);\n  }\n}\n\nfunction Scene_0(){\n  this.drawables = new ArrayList_0;\n  this.animations = new HashSet_0;\n}\n\ndefineSeed(20, 1, {}, Scene_0);\nfunction arcView(graph, engine, bufferUsage){\n  var edgeView, nodeView;\n  nodeView = new NodeCircleView_0(graph, engine.gl, engine.camera, engine.circlesShader, bufferUsage);\n  edgeView = new EdgeArcView_0(graph, engine.gl, engine.camera, (engine.gl , engine.arcShader), bufferUsage);\n  return new GraphView_0(nodeView, edgeView);\n}\n\nfunction directedView(graph, engine, bufferUsage){\n  var edgeView, nodeView;\n  nodeView = new NodeCircleView_0(graph, engine.gl, engine.camera, engine.circlesShader, bufferUsage);\n  edgeView = new EdgeArrowView_0(graph, engine.gl, engine.camera, (engine.gl , engine.triangleShader), bufferUsage);\n  return new GraphView_0(nodeView, edgeView);\n}\n\nfunction simpleView(graph, engine, bufferUsage){\n  var edgeView, nodeView;\n  nodeView = new NodeCircleView_0(graph, engine.gl, engine.camera, engine.circlesShader, bufferUsage);\n  edgeView = new EdgeLineView_0(graph, engine.gl, engine.camera, engine.linesShader, bufferUsage);\n  return new GraphView_0(nodeView, edgeView);\n}\n\nfunction NodePositions_0(){\n  this.nodeData = new ArrayList_0;\n}\n\ndefineSeed(22, 1, {}, NodePositions_0);\nfunction NodePositions$NodeData_0(){\n}\n\ndefineSeed(23, 1, makeCastMap([Q$NodePositions$NodeData]), NodePositions$NodeData_0);\nfunction $convergenceProgress(this$static){\n  var end, progress;\n  progress = log_1(this$static.currentIteration + 1);\n  end = log_1(this$static.maxIterations + 1);\n  return progress / end;\n}\n\nfunction $createEmptyProgress(this$static){\n  var ans, data_0, n, n$iterator;\n  ans = new NodePositions_0;\n  for (n$iterator = $iterator($keySet(this$static.input_0.adjacency.adjacency)); $hasNext(n$iterator.val$outerIter.iter);) {\n    n = $next_1(n$iterator);\n    data_0 = new NodePositions$NodeData_0;\n    data_0.node = n;\n    data_0.position = new JVec2_2(dynamicCast(n, Q$Node).position.mData);\n    data_0.force = new JVec2_0;\n    $add_1(ans.nodeData, data_0);\n  }\n  return ans;\n}\n\nfunction $doWork(this$static){\n  var dist, distSq, edge, force, forceMag, i, j, node, node$iterator, numNodes, potentialNeighbor, preferredDist, scale;\n  numNodes = this$static.nodes.nodeData.size_0;\n  for (i = 0; i < numNodes; i++) {\n    node = dynamicCast($get_0(this$static.nodes.nodeData, i), Q$NodePositions$NodeData);\n    $set(node.force, 0, 0);\n    for (j = 0; j < numNodes; j++) {\n      potentialNeighbor = dynamicCast($get_0(this$static.nodes.nodeData, j), Q$NodePositions$NodeData);\n      if (maskUndefined(node.node) === maskUndefined(potentialNeighbor.node)) {\n        continue;\n      }\n      $subtract(this$static.lDistToNode, potentialNeighbor.position, node.position);\n      dist = $norm(this$static.lDistToNode);\n      distSq = dist * dist;\n      edge = dynamicCast($get_0(this$static.matrix.adjacencyMatrix, i), Q$List).get_1(j);\n      if (edge != null) {\n        preferredDist = dynamicCast(edge, Q$Edge).preferredLength;\n        force = dist / preferredDist - preferredDist * preferredDist / distSq;\n        $scaleAndAdd(node.force, node.force, this$static.lDistToNode, force);\n      }\n       else {\n        force = -this$static.input_0.preferredLengthNotNeihbors * this$static.input_0.preferredLengthNotNeihbors / distSq;\n        $scaleAndAdd(node.force, node.force, this$static.lDistToNode, force);\n      }\n    }\n  }\n  ++this$static.currentIteration;\n  this$static.currentTemp = this$static.initTemp / this$static.currentIteration;\n  for (node$iterator = new AbstractList$IteratorImpl_0(this$static.nodes.nodeData); node$iterator.i < node$iterator.this$0.size_0;) {\n    node = dynamicCast($next_0(node$iterator), Q$NodePositions$NodeData);\n    forceMag = $norm(node.force);\n    scale = min_0(forceMag, this$static.currentTemp) / forceMag;\n    $scaleAndAdd(node.position, node.position, node.force, scale);\n  }\n  return this$static.currentIteration >= this$static.maxIterations;\n}\n\nfunction $maxCoord(nodePositions){\n  var data_0, data$iterator, maxCoord;\n  maxCoord = 0;\n  for (data$iterator = new AbstractList$IteratorImpl_0(nodePositions.nodeData); data$iterator.i < data$iterator.this$0.size_0;) {\n    data_0 = dynamicCast($next_0(data$iterator), Q$NodePositions$NodeData);\n    maxCoord = max_0(maxCoord, abs_0(data_0.position.mData[0]));\n    maxCoord = max_0(maxCoord, abs_0(data_0.position.mData[1]));\n  }\n  return maxCoord;\n}\n\nfunction $publishProgress(this$static, progressOutputBuffer){\n  var i, outNode, selfNode;\n  for (i = 0; i < this$static.nodes.nodeData.size_0; i++) {\n    outNode = dynamicCast($get_0(progressOutputBuffer.nodeData, i), Q$NodePositions$NodeData);\n    selfNode = dynamicCast($get_0(this$static.nodes.nodeData, i), Q$NodePositions$NodeData);\n    $copy(outNode.force, selfNode.force);\n    $copy(outNode.position, selfNode.position);\n  }\n}\n\nfunction $runtimeProgress(this$static){\n  return this$static.currentIteration / this$static.maxIterations;\n}\n\nfunction SpringLayout_0(input_0){\n  this.input_0 = input_0;\n  this.lDistToNode = new JVec2_0;\n  this.matrix = new UndirectedMatrixAdjacency_0(input_0.adjacency);\n  this.nodes = $createEmptyProgress(this);\n  this.initTemp = 2 * $maxCoord(this.nodes);\n  this.currentTemp = this.initTemp;\n  this.maxIterations = 100;\n  this.currentIteration = 0;\n}\n\ndefineSeed(24, 1, makeCastMap([Q$CooperativeTask]), SpringLayout_0);\n_.currentIteration = 0;\n_.currentTemp = 0;\n_.initTemp = 0;\n_.maxIterations = 0;\nfunction generateErdosRenyiGraph(numNodes, edgeProbability){\n  var ans, edge, i, i0, j, node, nodes;\n  ans = new UndirectedGraph_0;\n  nodes = initDim(_3Lcom_github_rma350_jgraphv_core_graph_typed_Node_2_classLit, makeCastMap([Q$Serializable]), Q$Node, numNodes, 0);\n  for (i0 = 0; i0 < numNodes; i0++) {\n    node = new Node_1;\n    $set(node.position, random() * 600, random() * 600);\n    node.radius = 20;\n    $addNode_0(ans.adjacency, node);\n    nodes[i0] = node;\n  }\n  for (i = 0; i < numNodes; i++) {\n    for (j = i + 1; j < numNodes; j++) {\n      if (random() < edgeProbability) {\n        edge = new Edge_0;\n        edge.preferredLength = 60;\n        $addEdge_0(ans.adjacency, nodes[i], nodes[j], edge);\n      }\n    }\n  }\n  return ans;\n}\n\nfunction generateDirectedGeometricGraph(nodes, minDistForEdge){\n  var ans, edge, i, j, minDistForEdgeSq, node, node$index, node$max;\n  ans = new DirectedGraph_0;\n  for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {\n    node = nodes[node$index];\n    $addNode(ans.adjacency, node);\n  }\n  minDistForEdgeSq = minDistForEdge * minDistForEdge;\n  for (i = 0; i < nodes.length; i++) {\n    for (j = i + 1; j < nodes.length; j++) {\n      if ($distSquared(nodes[i].position, nodes[j].position) < minDistForEdgeSq) {\n        edge = new Edge_0;\n        $addEdge(ans.adjacency, nodes[i], nodes[j], edge);\n      }\n    }\n  }\n  return ans;\n}\n\nfunction generateUndirectedGeometricGraph(nodes, minDistForEdge){\n  var ans, edge, i, j, minDistForEdgeSq, node, node$index, node$max;\n  ans = new UndirectedGraph_0;\n  for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {\n    node = nodes[node$index];\n    $addNode_0(ans.adjacency, node);\n  }\n  minDistForEdgeSq = minDistForEdge * minDistForEdge;\n  for (i = 0; i < nodes.length; i++) {\n    for (j = i + 1; j < nodes.length; j++) {\n      if ($distSquared(nodes[i].position, nodes[j].position) < minDistForEdgeSq) {\n        edge = new Edge_0;\n        $addEdge_0(ans.adjacency, nodes[i], nodes[j], edge);\n      }\n    }\n  }\n  return ans;\n}\n\nfunction randomPositionNodes(numNodes, minPos, maxPos, nodeRadius){\n  var i, node, nodes;\n  nodes = initDim(_3Lcom_github_rma350_jgraphv_core_graph_typed_Node_2_classLit, makeCastMap([Q$Serializable]), Q$Node, numNodes, 0);\n  for (i = 0; i < numNodes; i++) {\n    node = new Node_1;\n    $setX(node.position, lerp(minPos.mData[0], maxPos.mData[0], random()));\n    $setY(node.position, lerp(minPos.mData[1], maxPos.mData[1], random()));\n    node.radius = nodeRadius;\n    nodes[i] = node;\n  }\n  return nodes;\n}\n\nfunction $clinit_AnimatedGraphLayout(){\n  $clinit_AnimatedGraphLayout = nullMethod;\n  TAG = Lcom_github_rma350_jgraphv_core_graph_rendering_AnimatedGraphLayout_2_classLit.simpleName;\n}\n\nfunction $normalizeRealTime(this$static, timeMs){\n  return toDouble(timeMs) / toDouble(this$static.animationLengthMs);\n}\n\nfunction $update_1(this$static, ellapsedMs){\n  var data_0, data$iterator, fracDistToMove, timeRemaining, animationTimeCurrent, animationTimeNext;\n  if (!this$static.nodePositions) {\n    return false;\n  }\n  timeRemaining = sub_0(this$static.animationLengthMs, this$static.currentAnimationTimeMs);\n  $e(TAG, 'Time remaining: ' + toString_6(timeRemaining));\n  ellapsedMs = !gte_0(ellapsedMs, timeRemaining)?ellapsedMs:timeRemaining;\n  fracDistToMove = (animationTimeCurrent = sqrt_0($normalizeRealTime(this$static, this$static.currentAnimationTimeMs)) , animationTimeNext = sqrt_0($normalizeRealTime(this$static, add_0(this$static.currentAnimationTimeMs, ellapsedMs))) , (animationTimeNext - animationTimeCurrent) / (1 - animationTimeCurrent));\n  for (data$iterator = new AbstractList$IteratorImpl_0(this$static.nodePositions.nodeData); data$iterator.i < data$iterator.this$0.size_0;) {\n    data_0 = dynamicCast($next_0(data$iterator), Q$NodePositions$NodeData);\n    $lerp(dynamicCast(data_0.node, Q$Node).position, dynamicCast(data_0.node, Q$Node).position, data_0.position, fracDistToMove);\n  }\n  this$static.currentAnimationTimeMs = add_0(this$static.currentAnimationTimeMs, ellapsedMs);\n  $update_2(this$static.graphView);\n  return gte_0(this$static.currentAnimationTimeMs, this$static.animationLengthMs);\n}\n\nfunction $updateNodePositions(this$static, positions){\n  this$static.nodePositions = positions;\n}\n\nfunction AnimatedGraphLayout_0(graphView){\n  $clinit_AnimatedGraphLayout();\n  this.animationLengthMs = Pfa0_longLit;\n  this.graphView = graphView;\n  this.currentAnimationTimeMs = P0_longLit;\n  this.nodePositions = null;\n  this.coopListener = new AnimatedGraphLayout$1_0(this);\n}\n\ndefineSeed(27, 1, makeCastMap([Q$Animation]), AnimatedGraphLayout_0);\n_.animationLengthMs = P0_longLit;\n_.currentAnimationTimeMs = P0_longLit;\nvar TAG;\nfunction $onPercentComplete(convergenceProgress){\n  $e(($clinit_AnimatedGraphLayout() , TAG), 'Animation progress update: ' + convergenceProgress);\n}\n\nfunction $onProgress(this$static, progress){\n  $updateNodePositions(this$static.this$0, progress);\n}\n\nfunction $onResult(this$static, result){\n  $e(($clinit_AnimatedGraphLayout() , TAG), 'Result ready');\n  $updateNodePositions(this$static.this$0, result);\n}\n\nfunction AnimatedGraphLayout$1_0(this$0){\n  this.this$0 = this$0;\n}\n\ndefineSeed(28, 1, {}, AnimatedGraphLayout$1_0);\nfunction $updateEdgePos(this$static){\n  var edge, edge$iterator, edgeIndex, internalEdge;\n  edgeIndex = 0;\n  for (edge$iterator = $iterator($keySet(this$static.graph.adjacency.edgeLookup)); $hasNext(edge$iterator.val$outerIter.iter);) {\n    edge = dynamicCast($next_1(edge$iterator), Q$Edge);\n    internalEdge = $internalEdge_0(this$static.graph.adjacency, edge);\n    $copy(this$static.arcBuilder.iFrom, internalEdge.start_0.position);\n    $copy(this$static.arcBuilder.iTo, internalEdge.end.position);\n    $computeArc(this$static.arcBuilder);\n    $updateArc(this$static.bufferBuilder, this$static.arcBuilder, edgeIndex);\n    ++edgeIndex;\n  }\n  $checkedPut(this$static.arcBuffer, this$static.bufferBuilder.buffer, this$static.bufferBuilder.sizeInFloats);\n}\n\nfunction EdgeArcView_0(graph, gl, camera, arcShader, bufferUsage){\n  this.graph = graph;\n  this.arcBuilder = new ArcBuilder_0;\n  this.bufferBuilder = new ArcBufferBuilder_0;\n  this.arcBuilder.iArcWidth = 3;\n  this.arcBuilder.iArcRadians = 1.0471975803375244;\n  this.arcBuffer = new ArcBuffer_0(gl, graph.adjacency.edgeLookup.size_0, bufferUsage);\n  $updateEdgePos(this);\n  this.arcs = new Arcs_0(camera, arcShader, this.arcBuffer);\n}\n\ndefineSeed(29, 1, makeCastMap([Q$Drawable]), EdgeArcView_0);\n_.draw = function draw(){\n  $draw_1(this.arcs);\n}\n;\n_.update = function update(){\n  $updateEdgePos(this);\n  $bindRebufferUnbind(this.arcBuffer);\n}\n;\nfunction $updateEdgePos_0(this$static){\n  var edge, edge$iterator, edgeIndex, internalEdge;\n  edgeIndex = 0;\n  for (edge$iterator = $iterator($keySet(this$static.graph.adjacency.edgeLookup)); $hasNext(edge$iterator.val$outerIter.iter);) {\n    edge = dynamicCast($next_1(edge$iterator), Q$Edge);\n    internalEdge = $internalEdge(this$static.graph.adjacency, edge);\n    $copy(this$static.lSrcVec, internalEdge.start_0.position);\n    $copy(this$static.lDestVec, internalEdge.end.position);\n    $setArrow_0(this$static.edgeBuffer, edgeIndex, this$static.lSrcVec, this$static.lDestVec, this$static.arrowWidth, this$static.arrowHeadWidth, this$static.arrowHeadLength, internalEdge.start_0.radius * 0.8999999761581421, internalEdge.end.radius);\n    ++edgeIndex;\n  }\n  $writeToNative(this$static.edgeBuffer);\n}\n\nfunction EdgeArrowView_0(graph, gl, camera, triangleShader, bufferUsage){\n  var edgeCount;\n  this.graph = graph;\n  edgeCount = graph.adjacency.edgeLookup.size_0;\n  this.arrowWidth = 2;\n  this.arrowHeadWidth = 5;\n  this.arrowHeadLength = 10;\n  this.lSrcVec = new JVec2_0;\n  this.lDestVec = new JVec2_0;\n  this.edgeBuffer = new DirectedArrowBuffer_0(gl, edgeCount, bufferUsage);\n  $updateEdgePos_0(this);\n  this.edgeLines = new DirectedLines_0(camera, triangleShader, this.edgeBuffer.triangleBuffer);\n}\n\ndefineSeed(30, 1, makeCastMap([Q$Drawable]), EdgeArrowView_0);\n_.draw = function draw_0(){\n  $draw_4(this.edgeLines);\n}\n;\n_.update = function update_0(){\n  $updateEdgePos_0(this);\n  $bindRebufferUnbind(this.edgeBuffer.triangleBuffer);\n}\n;\n_.arrowHeadLength = 0;\n_.arrowHeadWidth = 0;\n_.arrowWidth = 0;\n",
"function $updateEdgePos_1(this$static){\n  var edge, edge$iterator, edgeIndex, internalEdge;\n  edgeIndex = 0;\n  for (edge$iterator = $iterator($keySet(this$static.graph.adjacency.edgeLookup)); $hasNext(edge$iterator.val$outerIter.iter);) {\n    edge = dynamicCast($next_1(edge$iterator), Q$Edge);\n    internalEdge = $internalEdge_0(this$static.graph.adjacency, edge);\n    setLine(this$static.lEdgePos, edgeIndex, internalEdge.start_0.position.mData[0], internalEdge.start_0.position.mData[1], internalEdge.end.position.mData[0], internalEdge.end.position.mData[1]);\n    ++edgeIndex;\n  }\n  $checkedPutShapes(this$static.edgeBuffer, this$static.lEdgePos);\n}\n\nfunction EdgeLineView_0(graph, gl, camera, linesShader, bufferUsage){\n  var numEdges;\n  this.graph = graph;\n  numEdges = graph.adjacency.edgeLookup.size_0;\n  this.edgeBuffer = new LinesBuffer_0(gl, numEdges, bufferUsage);\n  this.lEdgePos = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, numEdges * 2 * 2, 1));\n  $updateEdgePos_1(this);\n  this.edgeLines = new Lines_0(camera, linesShader, this.edgeBuffer, 4);\n}\n\ndefineSeed(31, 1, makeCastMap([Q$Drawable]), EdgeLineView_0);\n_.draw = function draw_1(){\n  $draw_5(this.edgeLines);\n}\n;\n_.update = function update_1(){\n  $updateEdgePos_1(this);\n  $bindRebufferUnbind(this.edgeBuffer);\n}\n;\nfunction $update_2(this$static){\n  this$static.edgeView.update();\n  $update_3(this$static.nodeView);\n}\n\nfunction GraphView_0(nodeView, edgeView){\n  this.nodeView = nodeView;\n  this.edgeView = edgeView;\n}\n\ndefineSeed(32, 1, makeCastMap([Q$Drawable]), GraphView_0);\n_.draw = function draw_2(){\n  this.edgeView.draw();\n  $draw_2(this.nodeView.nodeCircles);\n}\n;\nfunction $update_3(this$static){\n  $updateNodePos(this$static);\n  $bindRebufferUnbind(this$static.nodeBuffer);\n}\n\nfunction $updateNodePos(this$static){\n  var node, node$iterator, nodeIndex;\n  nodeIndex = 0;\n  for (node$iterator = this$static.graph.getAdjacency().nodes_0().iterator(); node$iterator.hasNext();) {\n    node = dynamicCast(node$iterator.next(), Q$Node);\n    setCircle(this$static.lNodePos, nodeIndex, node.position.mData[0], node.position.mData[1], node.radius);\n    ++nodeIndex;\n  }\n  $checkedPutShapes(this$static.nodeBuffer, this$static.lNodePos);\n}\n\nfunction NodeCircleView_0(graph, gl, camera, circlesShader, bufferUsage){\n  var numNodes;\n  this.graph = graph;\n  numNodes = graph.getAdjacency().numNodes_0();\n  this.nodeBuffer = new CirclesBuffer_0(gl, numNodes, bufferUsage);\n  this.lNodePos = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, numNodes * 6 * 4, 1));\n  $updateNodePos(this);\n  this.nodeCircles = new Circles_0(camera, circlesShader, this.nodeBuffer);\n}\n\ndefineSeed(33, 1, makeCastMap([Q$Drawable]), NodeCircleView_0);\n_.draw = function draw_3(){\n  $draw_2(this.nodeCircles);\n}\n;\nfunction DirectedGraph_0(){\n  this.adjacency = new DirectedHashAdjacency_0;\n}\n\ndefineSeed(34, 1, {}, DirectedGraph_0);\n_.getAdjacency = function getAdjacency(){\n  return this.adjacency;\n}\n;\nfunction $addEdge(this$static, m_0, n, edge){\n  var iEdge;\n  $assertContainsNode(this$static, m_0, true);\n  $assertContainsNode(this$static, n, true);\n  iEdge = new InternalEdge_0(m_0, n, edge);\n  dynamicCast($get(this$static.outgoingEdges, m_0), Q$Map).put(n, iEdge);\n  dynamicCast($get(this$static.incomingEdges, n), Q$Map).put(m_0, iEdge);\n  $put(this$static.edgeLookup, edge, iEdge);\n}\n\nfunction $addNode(this$static, n){\n  $assertContainsNode(this$static, n, false);\n  $put(this$static.outgoingEdges, n, new HashMap_0);\n  $put(this$static.incomingEdges, n, new HashMap_0);\n}\n\nfunction $assertContainsNode(this$static, n, contains){\n  if ($containsKey(this$static.outgoingEdges, n) != contains || $containsKey(this$static.incomingEdges, n) != contains) {\n    throw new RuntimeException_1('Expected graph containment of node: ' + n + ' to be: ' + contains + ' but was: ' + !contains);\n  }\n}\n\nfunction $internalEdge(this$static, edge){\n  return dynamicCast($get(this$static.edgeLookup, edge), Q$InternalEdge);\n}\n\nfunction DirectedHashAdjacency_0(){\n  this.outgoingEdges = new HashMap_0;\n  this.incomingEdges = new HashMap_0;\n  this.edgeLookup = new HashMap_0;\n}\n\ndefineSeed(35, 1, {}, DirectedHashAdjacency_0);\n_.nodes_0 = function nodes_0(){\n  return $keySet(this.outgoingEdges);\n}\n;\n_.numNodes_0 = function numNodes_0(){\n  return this.outgoingEdges.size_0;\n}\n;\nfunction InternalEdge_0(start_0, end, edge){\n  this.start_0 = start_0;\n  this.end = end;\n  this.edge = edge;\n}\n\ndefineSeed(36, 1, makeCastMap([Q$InternalEdge]), InternalEdge_0);\n_.toString$ = function toString_1(){\n  return 'start: ' + this.start_0 + ' end: ' + this.end + ' edge: ' + this.edge;\n}\n;\nfunction UndirectedGraph_0(){\n  this.adjacency = new UndirectedHashAdjacency_0;\n}\n\ndefineSeed(37, 1, {}, UndirectedGraph_0);\n_.getAdjacency = function getAdjacency_0(){\n  return this.adjacency;\n}\n;\nfunction $addEdge_0(this$static, m_0, n, edge){\n  var iEdge;\n  $assertContainsNode_0(this$static, m_0, true);\n  $assertContainsNode_0(this$static, n, true);\n  iEdge = new InternalEdge_0(m_0, n, edge);\n  dynamicCast($get(this$static.adjacency, m_0), Q$Map).put(n, iEdge);\n  dynamicCast($get(this$static.adjacency, n), Q$Map).put(m_0, iEdge);\n  $put(this$static.edgeLookup, edge, iEdge);\n}\n\nfunction $addNode_0(this$static, n){\n  $assertContainsNode_0(this$static, n, false);\n  $put(this$static.adjacency, n, new HashMap_0);\n}\n\nfunction $assertContainsNode_0(this$static, n, contains){\n  if ($containsKey(this$static.adjacency, n) != contains) {\n    throw new RuntimeException_1('Expected graph containment of node: ' + n + ' to be: ' + contains + ' but was: ' + !contains);\n  }\n}\n\nfunction $internalEdge_0(this$static, edge){\n  return dynamicCast($get(this$static.edgeLookup, edge), Q$InternalEdge);\n}\n\nfunction UndirectedHashAdjacency_0(){\n  this.adjacency = new HashMap_0;\n  this.edgeLookup = new HashMap_0;\n}\n\ndefineSeed(38, 1, {}, UndirectedHashAdjacency_0);\n_.nodes_0 = function nodes_1(){\n  return $keySet(this.adjacency);\n}\n;\n_.numNodes_0 = function numNodes_1(){\n  return this.adjacency.size_0;\n}\n;\nfunction UndirectedMatrixAdjacency_0(other){\n  var i, iNeighbors, j, ni, nj, node, node$iterator, nodeInd, numNodes;\n  numNodes = other.adjacency.size_0;\n  nodeInd = 0;\n  this.nodeIndex = new HashMap_0;\n  this.nodesInOrder = new ArrayList_0;\n  this.adjacencyMatrix = new ArrayList_0;\n  for (node$iterator = $iterator($keySet(other.adjacency)); $hasNext(node$iterator.val$outerIter.iter);) {\n    node = $next_1(node$iterator);\n    $put(this.nodeIndex, node, valueOf(nodeInd++));\n    $add_1(this.nodesInOrder, node);\n    $add_1(this.adjacencyMatrix, new ArrayList_0);\n  }\n  for (i = 0; i < numNodes; i++) {\n    ni = $get_0(this.nodesInOrder, i);\n    iNeighbors = dynamicCast($get_0(this.adjacencyMatrix, i), Q$List);\n    for (j = 0; j < numNodes; j++) {\n      nj = $get_0(this.nodesInOrder, j);\n      i == j?iNeighbors.add_0(null):iNeighbors.add_0(dynamicCast($get(other.adjacency, ni), Q$Map).containsKey(nj)?dynamicCast(dynamicCast($get(other.adjacency, ni), Q$Map).get_0(nj), Q$InternalEdge).edge:null);\n    }\n  }\n}\n\ndefineSeed(39, 1, {}, UndirectedMatrixAdjacency_0);\n_.nodes_0 = function nodes_2(){\n  return this.nodesInOrder;\n}\n;\n_.numNodes_0 = function numNodes_2(){\n  return this.nodesInOrder.size_0;\n}\n;\nfunction Edge_0(){\n}\n\ndefineSeed(40, 1, makeCastMap([Q$Edge]), Edge_0);\n_.preferredLength = 0;\nfunction LayoutInput_0(adjacency){\n  this.adjacency = adjacency;\n  this.preferredLengthNotNeihbors = 60;\n}\n\ndefineSeed(41, 1, {}, LayoutInput_0);\n_.preferredLengthNotNeihbors = 0;\nfunction Node_1(){\n  this.position = new JVec2_0;\n}\n\ndefineSeed(42, 1, makeCastMap([Q$Node]), Node_1);\n_.radius = 0;\nfunction $d(tag, message){\n  $log_1(($clinit_Logger() , $getLoggerHelper(tag)), ($clinit_Level() , INFO), message);\n}\n\nfunction $e(tag, message){\n  $log_1(($clinit_Logger() , $getLoggerHelper(tag)), ($clinit_Level() , SEVERE), message);\n}\n\nfunction $add(out, a, b){\n  var ad, bd, od;\n  od = out.mData;\n  ad = a.mData;\n  bd = b.mData;\n  od[0] = ad[0] + bd[0];\n  od[1] = ad[1] + bd[1];\n}\n\nfunction $distSquared(a, b){\n  var ad, bd, dx, dy;\n  ad = a.mData;\n  bd = b.mData;\n  dx = bd[0] - ad[0];\n  dy = bd[1] - ad[1];\n  return dx * dx + dy * dy;\n}\n\nfunction $lerp(out, a, b, t){\n  var ad, bd, od;\n  od = out.mData;\n  ad = a.mData;\n  bd = b.mData;\n  od[0] = (1 - t) * ad[0] + t * bd[0];\n  od[1] = (1 - t) * ad[1] + t * bd[1];\n}\n\nfunction $norm(vec){\n  var v;\n  v = vec.mData;\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n\nfunction $normalize(out, a){\n  var n, o;\n  n = $norm(a);\n  o = out.mData;\n  o[0] = a.mData[0] / n;\n  o[1] = a.mData[1] / n;\n}\n\nfunction $scale(out, a){\n  var ad, od;\n  od = out.mData;\n  ad = a.mData;\n  od[0] = 0.5 * ad[0];\n  od[1] = 0.5 * ad[1];\n}\n\nfunction $scaleAndAdd(out, a, b, scale){\n  var ad, bd, od;\n  od = out.mData;\n  ad = a.mData;\n  bd = b.mData;\n  od[0] = ad[0] + scale * bd[0];\n  od[1] = ad[1] + scale * bd[1];\n}\n\nfunction $subtract(out, a, b){\n  var ad, bd, od;\n  od = out.mData;\n  ad = a.mData;\n  bd = b.mData;\n  od[0] = ad[0] - bd[0];\n  od[1] = ad[1] - bd[1];\n}\n\nfunction $copy(this$static, other){\n  this$static.mData[0] = other.mData[0];\n  this$static.mData[1] = other.mData[1];\n}\n\nfunction $set(this$static, x_0, y_0){\n  this$static.mData[0] = x_0;\n  this$static.mData[1] = y_0;\n}\n\nfunction $setX(this$static, x_0){\n  this$static.mData[0] = x_0;\n}\n\nfunction $setY(this$static, y_0){\n  this$static.mData[1] = y_0;\n}\n\nfunction JVec2_0(){\n  this.mData = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);\n}\n\nfunction JVec2_1(x_0, y_0){\n  this.mData = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);\n  this.mData[0] = x_0;\n  this.mData[1] = y_0;\n}\n\nfunction JVec2_2(other){\n  this.mData = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);\n  this.mData[0] = other[0];\n  this.mData[1] = other[1];\n}\n\ndefineSeed(45, 1, {}, JVec2_0, JVec2_1, JVec2_2);\n_.toString$ = function toString_2(){\n  return '(' + this.mData[0] + ',' + this.mData[1] + ')';\n}\n;\nfunction $cancelAll(this$static){\n  var task, task$iterator;\n  for (task$iterator = $iterator($keySet(this$static.tasks)); $hasNext(task$iterator.val$outerIter.iter);) {\n    task = dynamicCast($next_1(task$iterator), Q$CooperativeTask);\n    dynamicCast($remove(this$static.tasks, task), Q$SynchronousTaskRunner$TaskEntry);\n  }\n}\n\nfunction $submit(this$static, task, listener){\n  $put(this$static.tasks, task, new SynchronousTaskRunner$TaskEntry_0(task, listener));\n}\n\nfunction $update_4(this$static){\n  var complete, it, mapEntry;\n  for (it = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this$static.tasks)).this$0); $hasNext(it.iter);) {\n    mapEntry = it.last = dynamicCast($next_0(it.iter), Q$Map$Entry);\n    complete = $doWork(dynamicCast(mapEntry.getKey(), Q$CooperativeTask));\n    if (complete) {\n      $onComplete(dynamicCast(mapEntry.getValue(), Q$SynchronousTaskRunner$TaskEntry));\n      $remove_0(it);\n    }\n     else {\n      $onUpdate(dynamicCast(mapEntry.getValue(), Q$SynchronousTaskRunner$TaskEntry));\n    }\n  }\n}\n\nfunction SynchronousTaskRunner_0(){\n  this.tasks = new HashMap_0;\n}\n\ndefineSeed(46, 1, {}, SynchronousTaskRunner_0);\nfunction $onComplete(this$static){\n  $onResult(this$static.listener, this$static.task.nodes);\n}\n\nfunction $onUpdate(this$static){\n  $onPercentComplete(($runtimeProgress(this$static.task) , $convergenceProgress(this$static.task)));\n  $publishProgress(this$static.task, this$static.progress);\n  $onProgress(this$static.listener, this$static.progress);\n}\n\nfunction SynchronousTaskRunner$TaskEntry_0(task, listener){\n  this.task = task;\n  this.listener = listener;\n  this.progress = $createEmptyProgress(task);\n}\n\ndefineSeed(47, 1, makeCastMap([Q$SynchronousTaskRunner$TaskEntry]), SynchronousTaskRunner$TaskEntry_0);\nfunction $clinit_NativeShapeBuffer(){\n  $clinit_NativeShapeBuffer = nullMethod;\n  TAG_0 = Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer_2_classLit.simpleName;\n}\n\nfunction $bindRebufferUnbind(this$static){\n  $glBindBuffer(this$static.gl, this$static.gl.gl.ARRAY_BUFFER, this$static.glBuffer);\n  this$static.isOnGpu?$glBufferSubData(this$static.gl, this$static.gl.gl.ARRAY_BUFFER, this$static.vertexBuffer):$glBufferData(this$static.gl, this$static.gl.gl.ARRAY_BUFFER, this$static.vertexBuffer, $glUsageCode(this$static, this$static.bufferUsage));\n  $glBindBuffer(this$static.gl, this$static.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $checkedPut(this$static, vertexData, numFloats){\n  $validateFloatAlignment(this$static, numFloats);\n  $putAll_0(this$static.vertexBuffer, vertexData, numFloats);\n}\n\nfunction $checkedPutShapes(this$static, vertexData){\n  $validateFloatAlignment(this$static, vertexData.length);\n  $putAll(this$static.vertexBuffer, vertexData);\n}\n\nfunction $ensureOnGpu(this$static){\n  if (!this$static.isOnGpu) {\n    $glBufferData(this$static.gl, this$static.gl.gl.ARRAY_BUFFER, this$static.vertexBuffer, $glUsageCode(this$static, this$static.bufferUsage));\n    this$static.isOnGpu = true;\n  }\n}\n\nfunction $glUsageCode(this$static, usage){\n  switch (usage.ordinal) {\n    case 2:\n      return this$static.gl.gl.DYNAMIC_DRAW;\n    case 1:\n      return this$static.gl.gl.STATIC_DRAW;\n    case 0:\n      return this$static.gl.gl.STREAM_DRAW;\n    default:$e(TAG_0, 'Unrecognized usage: ' + usage.name_0);\n      return this$static.gl.gl.DYNAMIC_DRAW;\n  }\n}\n\nfunction $validateFloatAlignment(this$static, numFloats){\n  if (numFloats % (this$static.vertexSizeFloats * this$static.vertsPerShape) != 0) {\n    throw new RuntimeException_1('Expected num floats to be divisible by ' + this$static.vertexSizeFloats * this$static.vertsPerShape + ' but was ' + numFloats);\n  }\n}\n\nfunction NativeShapeBuffer_0(gl, vertexSizeFloats, vertsPerShape, numShapes, bufferUsage){\n  this.gl = gl;\n  this.numShapes = numShapes;\n  this.vertexSizeFloats = vertexSizeFloats;\n  this.vertsPerShape = vertsPerShape;\n  this.bufferUsage = bufferUsage;\n  this.vertexBuffer = new WebNativeFloatBuffer_0(vertexSizeFloats * vertsPerShape * numShapes);\n  this.glBuffer = $addBuffer(gl.webGLObjects, gl.gl.createBuffer());\n  this.modelMatrix = nCreateMat4();\n  nSetIdentity(this.modelMatrix);\n}\n\ndefineSeed(49, 1, {});\n_.glBuffer = 0;\n_.isOnGpu = false;\n_.numShapes = 0;\n_.vertexSizeFloats = 0;\n_.vertsPerShape = 0;\nvar TAG_0;\nfunction ArcBuffer_0(gl, numTriangles, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, ($clinit_ArcMemLayout() , VERTEX_SIZE), 3, numTriangles, bufferUsage);\n}\n\nfunction ArcBuffer_1(gl, arcBufferBuilder, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, ($clinit_ArcMemLayout() , VERTEX_SIZE), 3, ~~(arcBufferBuilder.sizeInFloats / 3), bufferUsage);\n  $checkedPut(this, arcBufferBuilder.buffer, arcBufferBuilder.sizeInFloats);\n}\n\ndefineSeed(48, 49, {}, ArcBuffer_0, ArcBuffer_1);\nfunction $ensureCapacity(this$static, numFloats){\n  var i, replacement;\n  if (this$static.buffer.length < numFloats) {\n    replacement = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, max_1(numFloats, this$static.buffer.length * 2), 1);\n    for (i = 0; i < this$static.sizeInFloats; i++) {\n      replacement[i] = this$static.buffer[i];\n    }\n    this$static.buffer = replacement;\n  }\n}\n\nfunction $updateArc(this$static, arcBuilder, arcIndex){\n  var requiredCapacity;\n  requiredCapacity = (arcIndex + 1) * ($clinit_ArcMemLayout() , FLOATS_PER_ARC_TRIANGLE);\n  $ensureCapacity(this$static, this$static.sizeInFloats + FLOATS_PER_ARC_TRIANGLE);\n  writeArcTriangle_0(this$static.buffer, arcIndex * FLOATS_PER_ARC_TRIANGLE, arcBuilder);\n  this$static.sizeInFloats = max_1(this$static.sizeInFloats, requiredCapacity);\n}\n\nfunction ArcBufferBuilder_0(){\n  this.buffer = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, ($clinit_ArcMemLayout() , FLOATS_PER_ARC_TRIANGLE), 1);\n  this.sizeInFloats = 0;\n}\n\nfunction writeArcTriangle(buffer, offset, t1, t2, t3, circleCenter, circleRadius, arcWidth){\n  writeVertex(buffer, offset, t1, circleCenter, circleRadius, arcWidth);\n  offset += ($clinit_ArcMemLayout() , VERTEX_SIZE);\n  writeVertex(buffer, offset, t2, circleCenter, circleRadius, arcWidth);\n  offset += VERTEX_SIZE;\n  writeVertex(buffer, offset, t3, circleCenter, circleRadius, arcWidth);\n  offset += VERTEX_SIZE;\n}\n\nfunction writeArcTriangle_0(buffer, offset, arcBuilder){\n  var t1, t2, t3;\n  t1 = arcBuilder.oFrom;\n  if (arcBuilder.iBendLeft) {\n    t2 = arcBuilder.oCircleCenter;\n    t3 = arcBuilder.oTo;\n  }\n   else {\n    t2 = arcBuilder.oTo;\n    t3 = arcBuilder.oCircleCenter;\n  }\n  writeArcTriangle(buffer, offset, t1, t2, t3, arcBuilder.oCircleCenter, arcBuilder.oCircleRadius, arcBuilder.iArcWidth);\n}\n\nfunction writeVec2(buffer, offset, vec2){\n  buffer[offset] = vec2.mData[0];\n  buffer[offset + 1] = vec2.mData[1];\n}\n\nfunction writeVertex(buffer, offset, position, circleCenter, circleRadius, arcWidth){\n  writeVec2(buffer, offset + ($clinit_ArcMemLayout() , POSITION_OFFSET), position);\n  writeVec2(buffer, offset + CIRCLE_CENTER_OFFSET, circleCenter);\n  buffer[offset + CIRCLE_RADIUS_OFFSET] = circleRadius;\n  buffer[offset + ARC_WIDTH_OFFSET] = arcWidth;\n}\n\ndefineSeed(50, 1, {}, ArcBufferBuilder_0);\n_.sizeInFloats = 0;\nfunction $computeArc(this$static){\n  var extendedRadius, fromAngle, fromToDist, perpLength, topWidth;\n  if (this$static.iArcRadians >= 3.141592653589793 || this$static.iArcRadians < 0) {\n    throw new RuntimeException_1('Arc radians should be between pi and 0 but was: ' + this$static.iArcRadians);\n  }\n  $add(this$static.lMid, this$static.iFrom, this$static.iTo);\n  $scale(this$static.lMid, this$static.lMid);\n  $subtract(this$static.lUnitParallel, this$static.iTo, this$static.iFrom);\n  fromToDist = $norm(this$static.lUnitParallel);\n  fromAngle = 1.5707963705062866 - this$static.iArcRadians / 2;\n  this$static.oCircleRadius = fromToDist / (2 * cos_0(fromAngle));\n  perpLength = cos_0(this$static.iArcRadians / 2) * this$static.oCircleRadius;\n  $normalize(this$static.lUnitParallel, this$static.lUnitParallel);\n  this$static.iBendLeft?$set(this$static.lUnitPerp, this$static.lUnitParallel.mData[1], -this$static.lUnitParallel.mData[0]):$set(this$static.lUnitPerp, -this$static.lUnitParallel.mData[1], this$static.lUnitParallel.mData[0]);\n  $scaleAndAdd(this$static.oCircleCenter, this$static.lMid, this$static.lUnitPerp, perpLength);\n  extendedRadius = this$static.oCircleRadius + this$static.iArcWidth / 2;\n  $scaleAndAdd(this$static.lArcFarMid, this$static.oCircleCenter, this$static.lUnitPerp, -extendedRadius);\n  topWidth = fromToDist * (extendedRadius / perpLength);\n  $scaleAndAdd(this$static.oFrom, this$static.lArcFarMid, this$static.lUnitParallel, -topWidth / 2);\n  $scaleAndAdd(this$static.oTo, this$static.lArcFarMid, this$static.lUnitParallel, topWidth / 2);\n}\n\nfunction ArcBuilder_0(){\n  this.iArcRadians = 1.5707963705062866;\n  this.iArcWidth = 1;\n  this.iBendLeft = true;\n  this.iFrom = new JVec2_0;\n  this.iTo = new JVec2_0;\n  this.lMid = new JVec2_0;\n  this.lUnitParallel = new JVec2_0;\n  this.lUnitPerp = new JVec2_0;\n  this.lArcFarMid = new JVec2_0;\n  this.oCircleCenter = new JVec2_0;\n  this.oFrom = new JVec2_0;\n  this.oTo = new JVec2_0;\n  this.oCircleRadius = 0;\n}\n\ndefineSeed(51, 1, {}, ArcBuilder_0);\n_.iArcRadians = 0;\n_.iArcWidth = 0;\n_.iBendLeft = false;\n_.oCircleRadius = 0;\nfunction $clinit_ArcMemLayout(){\n  $clinit_ArcMemLayout = nullMethod;\n  var offset;\n  offset = 0;\n  POSITION_OFFSET = 0;\n  offset += 2;\n  CIRCLE_CENTER_OFFSET = offset;\n  offset += 2;\n  CIRCLE_RADIUS_OFFSET = offset;\n  offset += 1;\n  ARC_WIDTH_OFFSET = offset;\n  offset += 1;\n  VERTEX_SIZE = offset;\n  FLOATS_PER_ARC_TRIANGLE = 3 * VERTEX_SIZE;\n}\n\nvar ARC_WIDTH_OFFSET = 0, CIRCLE_CENTER_OFFSET = 0, CIRCLE_RADIUS_OFFSET = 0, FLOATS_PER_ARC_TRIANGLE = 0, POSITION_OFFSET = 0, VERTEX_SIZE = 0;\nfunction $bindAttribute(this$static, attrHandle, attrSizeFloats, attrOffsetFloats){\n  $glVertexAttribPointer(this$static.gl, attrHandle, attrSizeFloats, 4 * ($clinit_ArcMemLayout() , VERTEX_SIZE), 4 * attrOffsetFloats);\n}\n\nfunction $draw_0(this$static, points){\n  $glUniformMatrix4(this$static.gl, this$static.uModel, points.modelMatrix);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, points.glBuffer);\n  $ensureOnGpu(points);\n  $bindAttribute(this$static, this$static.aPosition, 2, ($clinit_ArcMemLayout() , POSITION_OFFSET));\n  $bindAttribute(this$static, this$static.aCircleCenter, 2, CIRCLE_CENTER_OFFSET);\n  $bindAttribute(this$static, this$static.aCircleRadius, 1, CIRCLE_RADIUS_OFFSET);\n  $bindAttribute(this$static, this$static.aArcWidth, 1, ARC_WIDTH_OFFSET);\n  $glDrawArrays(this$static.gl, this$static.gl.gl.TRIANGLES, points.numShapes * points.vertsPerShape);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $use(this$static, r, g, b, a, camera){\n  $glUseProgram(this$static.gl, this$static.program);\n  $glEnableVertexAttribArray(this$static.gl, this$static.aPosition);\n  $glEnableVertexAttribArray(this$static.gl, this$static.aCircleCenter);\n  $glEnableVertexAttribArray(this$static.gl, this$static.aCircleRadius);\n  $glEnableVertexAttribArray(this$static.gl, this$static.aArcWidth);\n  $glUniform4f(this$static.gl, this$static.uColor, r, g, b, a);\n  $glUniformMatrix4(this$static.gl, this$static.uView, camera.view);\n  $glUniformMatrix4(this$static.gl, this$static.uProjection, camera.projection);\n}\n\nfunction ArcShader_0(gl){\n  this.gl = gl;\n  this.program = createProgram(gl, 'uniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nattribute vec4 aPosition;\\nattribute vec2 aCircleCenter;\\nattribute float aCircleRadius;\\nattribute float aArcWidth;\\nvarying vec2 vPositionCC;\\nvarying float vArcHalfWidthCC;\\nvoid main() {\\n  vec4 worldPos4 = uModel*aPosition;\\n  vPositionCC = (vec2(worldPos4) - aCircleCenter ) / aCircleRadius;\\n  vArcHalfWidthCC = aArcWidth /(2.0*aCircleRadius);\\n  gl_Position = uProjection * uView * worldPos4;\\n}\\n', 'precision mediump float;\\nuniform vec4 uColor;\\nvarying vec2 vPositionCC;\\nvarying float vArcHalfWidthCC;\\nvoid main() {\\n  float distSquared = dot(vPositionCC, vPositionCC);\\n  if(abs(distSquared - 1.0 - vArcHalfWidthCC*vArcHalfWidthCC) > 2.0*vArcHalfWidthCC) {\\n    discard;\\n  } else {\\n  gl_FragColor = uColor;\\n  }\\n}\\n');\n  this.aPosition = $glGetAttribLocation(gl, this.program, 'aPosition');\n  this.aCircleCenter = $glGetAttribLocation(gl, this.program, 'aCircleCenter');\n  this.aCircleRadius = $glGetAttribLocation(gl, this.program, 'aCircleRadius');\n  this.aArcWidth = $glGetAttribLocation(gl, this.program, 'aArcWidth');\n  this.uModel = $glGetUniformLocation(gl, this.program, 'uModel');\n  this.uView = $glGetUniformLocation(gl, this.program, 'uView');\n  this.uProjection = $glGetUniformLocation(gl, this.program, 'uProjection');\n  this.uColor = $glGetUniformLocation(gl, this.program, 'uColor');\n}\n\ndefineSeed(53, 1, {}, ArcShader_0);\n_.aArcWidth = 0;\n_.aCircleCenter = 0;\n_.aCircleRadius = 0;\n_.aPosition = 0;\n_.program = 0;\n_.uColor = 0;\n_.uModel = 0;\n_.uProjection = 0;\n_.uView = 0;\nfunction $draw_1(this$static){\n  $use(this$static.shader, this$static.r, this$static.g, this$static.b, this$static.a_0, this$static.camera);\n  $draw_0(this$static.shader, this$static.buffer);\n}\n\nfunction Arcs_0(camera, shader, buffer){\n  this.camera = camera;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.r = 1;\n  this.g = 0;\n  this.b = 0;\n  this.a_0 = 1;\n}\n\ndefineSeed(54, 1, makeCastMap([Q$Drawable]), Arcs_0);\n_.draw = function draw_4(){\n  $draw_1(this);\n}\n;\n_.a_0 = 0;\n_.b = 0;\n_.g = 0;\n_.r = 0;\nfunction $draw_2(this$static){\n  $use_0(this$static.shader, this$static.r, this$static.g, this$static.b, this$static.a_0, this$static.camera);\n  $draw_3(this$static.shader, this$static.buffer);\n}\n\nfunction Circles_0(camera, shader, buffer){\n  this.camera = camera;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.r = 0;\n  this.g = 0;\n  this.b = 1;\n  this.a_0 = 1;\n}\n\ndefineSeed(55, 1, makeCastMap([Q$Drawable]), Circles_0);\n_.draw = function draw_5(){\n  $draw_2(this);\n}\n;\n_.a_0 = 0;\n_.b = 0;\n_.g = 0;\n_.r = 0;\nfunction CirclesBuffer_0(gl, numCircles, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, 4, 6, numCircles, bufferUsage);\n}\n\nfunction setCircle(buffer, circleIndex, centerX, centerY, radius){\n  $clinit_NativeShapeBuffer();\n  var bottom, left, next, right, top_0;\n  next = circleIndex * 6 * 4;\n  top_0 = centerY + radius;\n  bottom = centerY - radius;\n  left = centerX - radius;\n  right = centerX + radius;\n  buffer[next++] = left;\n  buffer[next++] = top_0;\n  buffer[next++] = -1;\n  buffer[next++] = 1;\n  buffer[next++] = left;\n  buffer[next++] = bottom;\n  buffer[next++] = -1;\n  buffer[next++] = -1;\n  buffer[next++] = right;\n  buffer[next++] = bottom;\n  buffer[next++] = 1;\n  buffer[next++] = -1;\n  buffer[next++] = left;\n  buffer[next++] = top_0;\n  buffer[next++] = -1;\n  buffer[next++] = 1;\n  buffer[next++] = right;\n  buffer[next++] = bottom;\n  buffer[next++] = 1;\n  buffer[next++] = -1;\n  buffer[next++] = right;\n  buffer[next++] = top_0;\n  buffer[next++] = 1;\n  buffer[next++] = 1;\n}\n\ndefineSeed(56, 49, {}, CirclesBuffer_0);\nfunction $draw_3(this$static, points){\n  $glUniformMatrix4(this$static.gl, this$static.mModel, points.modelMatrix);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, points.glBuffer);\n  $ensureOnGpu(points);\n  $glVertexAttribPointer(this$static.gl, this$static.mPosition, 2, 16, 0);\n  $glVertexAttribPointer(this$static.gl, this$static.mCircleCoords, 2, 16, 8);\n  $glDrawArrays(this$static.gl, this$static.gl.gl.TRIANGLES, points.numShapes * points.vertsPerShape);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $use_0(this$static, r, g, b, a, camera){\n  $glUseProgram(this$static.gl, this$static.mProgram);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mCircleCoords);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mPosition);\n  $glUniform4f(this$static.gl, this$static.mColor, r, g, b, a);\n  $glUniformMatrix4(this$static.gl, this$static.mView, camera.view);\n  $glUniformMatrix4(this$static.gl, this$static.mProjection, camera.projection);\n}\n\nfunction CirclesShader_0(gl){\n  this.gl = gl;\n  this.mProgram = createProgram(gl, 'uniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nattribute vec4 aPosition;\\nattribute vec2 aCircleCoords;\\nvarying vec2 vCircleCoords;\\nvoid main() {\\n  vCircleCoords = aCircleCoords;\\n  gl_Position = uProjection*uView*uModel*aPosition;\\n}\\n', 'precision mediump float;\\nuniform vec4 uColor;\\nvarying vec2 vCircleCoords;\\nvoid main() {\\n  if(vCircleCoords.x * vCircleCoords.x + vCircleCoords.y * vCircleCoords.y < 1.0 ) {\\n    gl_FragColor = uColor;\\n  } else {\\n    gl_FragColor = vec4(0,0,0,0);\\n  }\\n}\\n');\n  this.mCircleCoords = $glGetAttribLocation(gl, this.mProgram, 'aCircleCoords');\n  this.mPosition = $glGetAttribLocation(gl, this.mProgram, 'aPosition');\n  this.mColor = $glGetUniformLocation(gl, this.mProgram, 'uColor');\n  this.mModel = $glGetUniformLocation(gl, this.mProgram, 'uModel');\n  this.mView = $glGetUniformLocation(gl, this.mProgram, 'uView');\n  this.mProjection = $glGetUniformLocation(gl, this.mProgram, 'uProjection');\n}\n\ndefineSeed(57, 1, {}, CirclesShader_0);\n_.mCircleCoords = 0;\n_.mColor = 0;\n_.mModel = 0;\n_.mPosition = 0;\n_.mProgram = 0;\n_.mProjection = 0;\n_.mView = 0;\nfunction $setArrow(this$static, arrowIndex, start_0, end, arrowWidth, arrowHeadWidth, arrowHeadLength){\n  var actualArrowHeadLength, distance, triangleIndex;\n  $subtract(this$static.l2DiffUnit, end, start_0);\n  distance = $norm(this$static.l2DiffUnit);\n  $normalize(this$static.l2DiffUnit, this$static.l2DiffUnit);\n  $set(this$static.lPerp, -this$static.l2DiffUnit.mData[1], this$static.l2DiffUnit.mData[0]);\n  $scaleAndAdd(this$static.lTopStart, start_0, this$static.lPerp, arrowWidth / 2);\n  $scaleAndAdd(this$static.lBottomStart, start_0, this$static.lPerp, -arrowWidth / 2);\n  actualArrowHeadLength = distance / 2 < arrowHeadLength?distance / 2:arrowHeadLength;\n  $scaleAndAdd(this$static.lLineEnd, end, this$static.l2DiffUnit, -actualArrowHeadLength);\n  $scaleAndAdd(this$static.lTopEnd, this$static.lLineEnd, this$static.lPerp, arrowWidth / 2);\n  $scaleAndAdd(this$static.lBottomEnd, this$static.lLineEnd, this$static.lPerp, -arrowWidth / 2);\n  $scaleAndAdd(this$static.lArrowStart, this$static.lLineEnd, this$static.lPerp, arrowHeadWidth / 2);\n  $scaleAndAdd(this$static.lArrowEnd, this$static.lLineEnd, this$static.lPerp, -arrowHeadWidth / 2);\n  triangleIndex = arrowIndex * 3;\n  setTriangle_0(this$static.buffer, triangleIndex++, this$static.lTopStart, this$static.lBottomStart, this$static.lTopEnd);\n  setTriangle_0(this$static.buffer, triangleIndex++, this$static.lBottomStart, this$static.lTopEnd, this$static.lBottomEnd);\n  setTriangle_0(this$static.buffer, triangleIndex++, this$static.lArrowStart, this$static.lArrowEnd, end);\n}\n\nfunction $setArrow_0(this$static, arrowIndex, start_0, end, arrowWidth, arrowHeadWidth, arrowHeadLength, startSpacing, endSpacing){\n  var distance;\n  $subtract(this$static.lDiffUnit, end, start_0);\n  distance = $norm(this$static.lDiffUnit);\n  $normalize(this$static.lDiffUnit, this$static.lDiffUnit);\n  $scaleAndAdd(this$static.lRealStart, start_0, this$static.lDiffUnit, startSpacing < distance / 3?startSpacing:distance / 3);\n  $scaleAndAdd(this$static.lRealEnd, end, this$static.lDiffUnit, -(endSpacing < distance / 3?endSpacing:distance / 3));\n  $setArrow(this$static, arrowIndex, this$static.lRealStart, this$static.lRealEnd, arrowWidth, arrowHeadWidth, arrowHeadLength);\n}\n\nfunction $writeToNative(this$static){\n  $checkedPutShapes(this$static.triangleBuffer, this$static.buffer);\n}\n\n",
"function DirectedArrowBuffer_0(gl, numArrows, bufferUsage){\n  var numTriangles;\n  numTriangles = numArrows * 3;\n  this.buffer = ($clinit_NativeShapeBuffer() , initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, numTriangles * 3 * 2, 1));\n  this.triangleBuffer = new TriangleBuffer_0(gl, numTriangles, bufferUsage);\n  this.lDiffUnit = new JVec2_0;\n  this.lRealStart = new JVec2_0;\n  this.lRealEnd = new JVec2_0;\n  this.l2DiffUnit = new JVec2_0;\n  this.lPerp = new JVec2_0;\n  this.lTopStart = new JVec2_0;\n  this.lBottomStart = new JVec2_0;\n  this.lTopEnd = new JVec2_0;\n  this.lBottomEnd = new JVec2_0;\n  this.lArrowStart = new JVec2_0;\n  this.lArrowEnd = new JVec2_0;\n  this.lLineEnd = new JVec2_0;\n}\n\ndefineSeed(58, 1, {}, DirectedArrowBuffer_0);\nfunction $draw_4(this$static){\n  $use_3(this$static.shader, this$static.r, this$static.g, this$static.b, this$static.a_0, this$static.camera);\n  $draw_8(this$static.shader, this$static.buffer);\n}\n\nfunction DirectedLines_0(camera, shader, buffer){\n  this.camera = camera;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.r = 1;\n  this.g = 0;\n  this.b = 0;\n  this.a_0 = 1;\n}\n\ndefineSeed(59, 1, makeCastMap([Q$Drawable]), DirectedLines_0);\n_.draw = function draw_6(){\n  $draw_4(this);\n}\n;\n_.a_0 = 0;\n_.b = 0;\n_.g = 0;\n_.r = 0;\nfunction $draw_5(this$static){\n  $use_1(this$static.shader, this$static.r, this$static.g, this$static.b, this$static.a_0, this$static.camera, this$static.width_0);\n  $draw_6(this$static.shader, this$static.buffer);\n}\n\nfunction Lines_0(camera, shader, buffer, width_0){\n  this.camera = camera;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.r = 1;\n  this.g = 0;\n  this.b = 0;\n  this.a_0 = 1;\n  this.width_0 = width_0;\n}\n\ndefineSeed(60, 1, makeCastMap([Q$Drawable]), Lines_0);\n_.draw = function draw_7(){\n  $draw_5(this);\n}\n;\n_.a_0 = 0;\n_.b = 0;\n_.g = 0;\n_.r = 0;\n_.width_0 = 0;\nfunction LinesBuffer_0(gl, numLines, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, 2, 2, numLines, bufferUsage);\n}\n\nfunction setLine(buffer, lineIndex, startX, startY, endX, endY){\n  $clinit_NativeShapeBuffer();\n  var next;\n  next = lineIndex * 2 * 2;\n  buffer[next++] = startX;\n  buffer[next++] = startY;\n  buffer[next++] = endX;\n  buffer[next++] = endY;\n}\n\ndefineSeed(61, 49, {}, LinesBuffer_0);\nfunction $draw_6(this$static, lines){\n  $glUniformMatrix4(this$static.gl, this$static.mModel, lines.modelMatrix);\n  $glBindBuffer(lines.gl, lines.gl.gl.ARRAY_BUFFER, lines.glBuffer);\n  $ensureOnGpu(lines);\n  $glVertexAttribPointer(this$static.gl, this$static.mPosition, 2, 8, 0);\n  $glDrawArrays(this$static.gl, this$static.gl.gl.LINES, lines.numShapes * lines.vertsPerShape);\n  $glBindBuffer(lines.gl, lines.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $use_1(this$static, r, g, b, a, camera, lineWidth){\n  var lineScreen, out, vec;\n  $glUseProgram(this$static.gl, this$static.mProgram);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mPosition);\n  $glUniform4f(this$static.gl, this$static.mColor, r, g, b, a);\n  $glUniformMatrix4(this$static.gl, this$static.mView, camera.view);\n  $glUniformMatrix4(this$static.gl, this$static.mProjection, camera.projection);\n  vec = nCreateVec4((this$static.gl , lineWidth), 0, 0, 0);\n  out = nMult((this$static.gl , camera.view), vec);\n  lineScreen = out[0];\n  $glLineWidth(this$static.gl, lineScreen);\n}\n\nfunction LinesShader_0(gl){\n  this.gl = gl;\n  this.mProgram = createProgram(gl, 'uniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nattribute vec4 aPosition;\\nvoid main() {\\n  gl_Position = uProjection*uView*uModel*aPosition;\\n}\\n', 'precision mediump float;\\nuniform vec4 uColor;\\nvoid main() {\\n  gl_FragColor = uColor;\\n}\\n');\n  this.mPosition = $glGetAttribLocation(gl, this.mProgram, 'aPosition');\n  this.mColor = $glGetUniformLocation(gl, this.mProgram, 'uColor');\n  this.mModel = $glGetUniformLocation(gl, this.mProgram, 'uModel');\n  this.mView = $glGetUniformLocation(gl, this.mProgram, 'uView');\n  this.mProjection = $glGetUniformLocation(gl, this.mProgram, 'uProjection');\n}\n\ndefineSeed(62, 1, {}, LinesShader_0);\n_.mColor = 0;\n_.mModel = 0;\n_.mPosition = 0;\n_.mProgram = 0;\n_.mProjection = 0;\n_.mView = 0;\nfunction Enum_0(name_0, ordinal){\n  this.name_0 = name_0;\n  this.ordinal = ordinal;\n}\n\ndefineSeed(64, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum]));\n_.equals$ = function equals_0(other){\n  return this === other;\n}\n;\n_.hashCode$ = function hashCode_1(){\n  return getHashCode(this);\n}\n;\n_.toString$ = function toString_3(){\n  return this.name_0;\n}\n;\n_.ordinal = 0;\nfunction $clinit_NativeShapeBuffer$BufferUsage(){\n  $clinit_NativeShapeBuffer$BufferUsage = nullMethod;\n  STREAM = new NativeShapeBuffer$BufferUsage_0('STREAM', 0);\n  STATIC = new NativeShapeBuffer$BufferUsage_0('STATIC', 1);\n  DYNAMIC = new NativeShapeBuffer$BufferUsage_0('DYNAMIC', 2);\n  $VALUES = initValues(_3Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer$BufferUsage_2_classLit, makeCastMap([Q$Serializable]), Q$NativeShapeBuffer$BufferUsage, [STREAM, STATIC, DYNAMIC]);\n}\n\nfunction NativeShapeBuffer$BufferUsage_0(enum$name, enum$ordinal){\n  Enum_0.call(this, enum$name, enum$ordinal);\n}\n\nfunction values_0(){\n  $clinit_NativeShapeBuffer$BufferUsage();\n  return $VALUES;\n}\n\ndefineSeed(63, 64, makeCastMap([Q$NativeShapeBuffer$BufferUsage, Q$Serializable, Q$Comparable, Q$Enum]), NativeShapeBuffer$BufferUsage_0);\nvar $VALUES, DYNAMIC, STATIC, STREAM;\nfunction Points_0(camera, shader, buffer){\n  this.camera = camera;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.r = 0;\n  this.g = 1;\n  this.b = 0;\n  this.a_0 = 1;\n}\n\ndefineSeed(65, 1, makeCastMap([Q$Drawable]), Points_0);\n_.draw = function draw_8(){\n  $use_2(this.shader, this.r, this.g, this.b, this.a_0, this.camera);\n  $draw_7(this.shader, this.buffer);\n}\n;\n_.a_0 = 0;\n_.b = 0;\n_.g = 0;\n_.r = 0;\nfunction PointsBuffer_0(gl, vertexData, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, 3, 1, ~~(vertexData.length / 3), bufferUsage);\n  $validateFloatAlignment(this, vertexData.length);\n  $validateFloatAlignment(this, vertexData.length);\n  $putAll(this.vertexBuffer, vertexData);\n}\n\ndefineSeed(66, 49, {}, PointsBuffer_0);\nfunction $draw_7(this$static, points){\n  $glUniformMatrix4(this$static.gl, this$static.mModel, points.modelMatrix);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, points.glBuffer);\n  $ensureOnGpu(points);\n  $glVertexAttribPointer(this$static.gl, this$static.mPosition, 2, 12, 0);\n  $glVertexAttribPointer(this$static.gl, this$static.mSize, 1, 12, 8);\n  $glDrawArrays(this$static.gl, this$static.gl.gl.POINTS, points.numShapes * points.vertsPerShape);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $use_2(this$static, r, g, b, a, camera){\n  $glUseProgram(this$static.gl, this$static.mProgram);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mSize);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mPosition);\n  $glUniform4f(this$static.gl, this$static.mColor, r, g, b, a);\n  $glUniformMatrix4(this$static.gl, this$static.mView, camera.view);\n  $glUniformMatrix4(this$static.gl, this$static.mProjection, camera.projection);\n}\n\nfunction PointsShader_0(gl){\n  this.gl = gl;\n  this.mProgram = createProgram(gl, 'uniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nattribute vec4 aPosition;\\nattribute float aSize;\\nvoid main() {\\n  gl_PointSize = (uView* vec4(aSize, 0 , 0 , 0)).x;\\n  gl_Position = uProjection*uView*uModel*aPosition;\\n}\\n', 'precision mediump float;\\nuniform vec4 uColor;\\nvoid main() {\\n  gl_FragColor = uColor;\\n}\\n');\n  this.mSize = $glGetAttribLocation(gl, this.mProgram, 'aSize');\n  this.mPosition = $glGetAttribLocation(gl, this.mProgram, 'aPosition');\n  this.mColor = $glGetUniformLocation(gl, this.mProgram, 'uColor');\n  this.mModel = $glGetUniformLocation(gl, this.mProgram, 'uModel');\n  this.mView = $glGetUniformLocation(gl, this.mProgram, 'uView');\n  this.mProjection = $glGetUniformLocation(gl, this.mProgram, 'uProjection');\n}\n\ndefineSeed(67, 1, {}, PointsShader_0);\n_.mColor = 0;\n_.mModel = 0;\n_.mPosition = 0;\n_.mProgram = 0;\n_.mProjection = 0;\n_.mSize = 0;\n_.mView = 0;\nfunction $clinit_ShaderUtil(){\n  $clinit_ShaderUtil = nullMethod;\n  TAG_1 = Lcom_github_rma350_jgraphv_core_shapes_ShaderUtil_2_classLit.simpleName;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader){\n  var program;\n  $clinit_ShaderUtil();\n  var fragmentProgram, linkStatus, programLog, shaderProgram, validationStatus, vertexProgram;\n  vertexProgram = loadShader(gl, gl.gl.VERTEX_SHADER, vertexShader);\n  fragmentProgram = loadShader(gl, gl.gl.FRAGMENT_SHADER, fragmentShader);\n  shaderProgram = (program = gl.gl.createProgram() , $addProgram(gl.webGLObjects, program));\n  glAttachShader(gl.gl, $getProgram(gl.webGLObjects, shaderProgram), $getShader(gl.webGLObjects, vertexProgram));\n  glAttachShader(gl.gl, $getProgram(gl.webGLObjects, shaderProgram), $getShader(gl.webGLObjects, fragmentProgram));\n  glLinkProgram(gl.gl, $getProgram(gl.webGLObjects, shaderProgram));\n  linkStatus = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);\n  $glGetProgramiv(gl, shaderProgram, gl.gl.LINK_STATUS, linkStatus);\n  if (linkStatus[0] == 0) {\n    $e(TAG_1, 'Program link failed');\n    $e(TAG_1, 'Vertex code:\\n' + vertexShader);\n    $e(TAG_1, 'Fragment code:\\n' + fragmentShader);\n    programLog = glProgramInfoLog(gl.gl, $getProgram(gl.webGLObjects, shaderProgram));\n    $e(TAG_1, programLog);\n    throw new RuntimeException_1(programLog);\n  }\n  glValidateProgram(gl.gl, $getProgram(gl.webGLObjects, shaderProgram));\n  validationStatus = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);\n  $glGetProgramiv(gl, shaderProgram, gl.gl.VALIDATE_STATUS, validationStatus);\n  if (validationStatus[0] == 0) {\n    $e(TAG_1, 'Program not valid');\n    $e(TAG_1, 'Vertex code:\\n' + vertexShader);\n    $e(TAG_1, 'Fragment code:\\n' + fragmentShader);\n    programLog = glProgramInfoLog(gl.gl, $getProgram(gl.webGLObjects, shaderProgram));\n    $e(TAG_1, programLog);\n    throw new RuntimeException_1(programLog);\n  }\n  glUseProgram(gl.gl, $getProgram(gl.webGLObjects, shaderProgram));\n  return shaderProgram;\n}\n\nfunction loadShader(gl, type_0, shaderCode){\n  var shader, shaderLog, status_0, shader_0;\n  shader = (shader_0 = glCreateShader(gl.gl, type_0) , $addShader(gl.webGLObjects, shader_0));\n  glShaderSource(gl.gl, $getShader(gl.webGLObjects, shader), shaderCode);\n  glCompileShader(gl.gl, $getShader(gl.webGLObjects, shader));\n  status_0 = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);\n  $glGetShaderiv(gl, shader, gl.gl.COMPILE_STATUS, status_0);\n  if (status_0[0] == 0) {\n    $e(TAG_1, 'Compile failed');\n    $e(TAG_1, 'Shader code:\\n' + shaderCode);\n    shaderLog = glShaderInfoLog(gl.gl, $getShader(gl.webGLObjects, shader));\n    $e(TAG_1, shaderLog);\n    throw new RuntimeException_1(shaderLog);\n  }\n  return shader;\n}\n\nvar TAG_1;\nfunction TriangleBuffer_0(gl, numTriangles, bufferUsage){\n  $clinit_NativeShapeBuffer();\n  NativeShapeBuffer_0.call(this, gl, 2, 3, numTriangles, bufferUsage);\n}\n\nfunction setTriangle(buffer, triangleIndex, x1, y1, x2, y2, x3, y3){\n  var next;\n  next = triangleIndex * 3 * 2;\n  buffer[next++] = x1;\n  buffer[next++] = y1;\n  buffer[next++] = x2;\n  buffer[next++] = y2;\n  buffer[next++] = x3;\n  buffer[next++] = y3;\n}\n\nfunction setTriangle_0(buffer, triangleIndex, v1, v2, v3){\n  $clinit_NativeShapeBuffer();\n  setTriangle(buffer, triangleIndex, v1.mData[0], v1.mData[1], v2.mData[0], v2.mData[1], v3.mData[0], v3.mData[1]);\n}\n\ndefineSeed(69, 49, {}, TriangleBuffer_0);\nfunction $draw_8(this$static, points){\n  $glUniformMatrix4(this$static.gl, this$static.mModel, points.modelMatrix);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, points.glBuffer);\n  $ensureOnGpu(points);\n  $glVertexAttribPointer(this$static.gl, this$static.mPosition, 2, 8, 0);\n  $glDrawArrays(this$static.gl, this$static.gl.gl.TRIANGLES, points.numShapes * points.vertsPerShape);\n  $glBindBuffer(points.gl, points.gl.gl.ARRAY_BUFFER, 0);\n}\n\nfunction $use_3(this$static, r, g, b, a, camera){\n  $glUseProgram(this$static.gl, this$static.mProgram);\n  $glEnableVertexAttribArray(this$static.gl, this$static.mPosition);\n  $glUniform4f(this$static.gl, this$static.mColor, r, g, b, a);\n  $glUniformMatrix4(this$static.gl, this$static.mView, camera.view);\n  $glUniformMatrix4(this$static.gl, this$static.mProjection, camera.projection);\n}\n\nfunction TriangleShader_0(gl){\n  this.gl = gl;\n  this.mProgram = createProgram(gl, 'uniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nattribute vec4 aPosition;\\nvoid main() {\\n  gl_Position = uProjection*uView*uModel*aPosition;\\n}\\n', 'precision mediump float;\\nuniform vec4 uColor;\\nvoid main() {\\n  gl_FragColor = uColor;\\n}\\n');\n  this.mPosition = $glGetAttribLocation(gl, this.mProgram, 'aPosition');\n  this.mColor = $glGetUniformLocation(gl, this.mProgram, 'uColor');\n  this.mModel = $glGetUniformLocation(gl, this.mProgram, 'uModel');\n  this.mView = $glGetUniformLocation(gl, this.mProgram, 'uView');\n  this.mProjection = $glGetUniformLocation(gl, this.mProgram, 'uProjection');\n}\n\ndefineSeed(70, 1, {}, TriangleShader_0);\n_.mColor = 0;\n_.mModel = 0;\n_.mPosition = 0;\n_.mProgram = 0;\n_.mProjection = 0;\n_.mView = 0;\nfunction $clinit_JGraphVWeb(){\n  $clinit_JGraphVWeb = nullMethod;\n  TAG_2 = Lcom_github_rma350_jgraphv_web_client_JGraphVWeb_2_classLit.simpleName;\n}\n\nfunction $publish(this$static){\n  var that = this$static;\n  $wnd.jSetupGL = $entry(function(){\n    that.setupGL();\n  }\n  );\n  $wnd.jResize = $entry(function(x_0, y_0){\n    that.resize(x_0, y_0);\n  }\n  );\n  $wnd.jDrawScene = $entry(function(){\n    that.drawScene();\n  }\n  );\n  $wnd.jUpdate = $entry(function(x_0){\n    that.update_0(x_0);\n  }\n  );\n  $wnd.jOnClick = $entry(function(x_0, y_0){\n    that.onClick(x_0, y_0);\n  }\n  );\n  $wnd.jOnMouseMove = $entry(function(x_0, y_0){\n    that.onMouseMove(x_0, y_0);\n  }\n  );\n  $wnd.jOnMouseWheel = $entry(function(x_0, y_0, d){\n    that.onMouseWheel(x_0, y_0, d);\n  }\n  );\n  $wnd.jOnZoomAbout = $entry(function(x_0, y_0, s){\n    that.onZoomAbout(x_0, y_0, s);\n  }\n  );\n  $wnd.jGetDemoNames = $entry(getDemoNames);\n  $wnd.jSetCurrentDemo = $entry(function(i){\n    that.setCurrentDemo(i);\n  }\n  );\n}\n\nfunction $resize(this$static, widthPx, heightPx){\n  $d(TAG_2, 'width, height: ' + widthPx + ', ' + heightPx);\n  $onResize(this$static.engine, widthPx, heightPx);\n  this$static.canvasHeight = heightPx;\n}\n\nfunction JGraphVWeb_0(){\n  $clinit_JGraphVWeb();\n}\n\nfunction getDemoNames(){\n  var ans, demo, demo$iterator;\n  ans = [];\n  for (demo$iterator = new AbstractList$IteratorImpl_0(allDemos()); demo$iterator.i < demo$iterator.this$0.size_0;) {\n    demo = dynamicCast($next_0(demo$iterator), Q$Demo);\n    $push(ans, demo.name_0);\n  }\n  return ans;\n}\n\ndefineSeed(71, 1, {}, JGraphVWeb_0);\n_.drawScene = function drawScene(){\n  $drawFrame(this.engine);\n}\n;\n_.onClick = function onClick(screenX_0, screenY_0){\n  $moveTo(this.engine.camera, screenX_0, this.canvasHeight - screenY_0);\n}\n;\n_.onMouseMove = function onMouseMove(deltaX, deltaY){\n  $translateBy(this.engine.camera, -deltaX, deltaY);\n}\n;\n_.onMouseWheel = function onMouseWheel(screenX_0, screenY_0, delta){\n  var zoom;\n  zoom = 1;\n  delta > 0?(zoom = 1.25):delta < 0 && (zoom = 0.800000011920929);\n  $zoom_0(this.engine, zoom, screenX_0, this.canvasHeight - screenY_0);\n}\n;\n_.onZoomAbout = function onZoomAbout(screenX_0, screenY_0, scaleFactor){\n  $d(TAG_2, 'Zoom about input at: ' + screenX_0 + ', ' + screenY_0 + ' delta ' + scaleFactor);\n  $zoom_0(this.engine, scaleFactor, screenX_0, this.canvasHeight - screenY_0);\n}\n;\n_.resize = function resize(widthPx, heightPx){\n  $resize(this, widthPx, heightPx);\n}\n;\n_.setCurrentDemo = function setCurrentDemo(demoIndex){\n  $reset(this.engine);\n  this.currentDemo = demoIndex;\n  dynamicCast($get_0(allDemos(), this.currentDemo), Q$Demo).setup(this.engine);\n}\n;\n_.setupGL = function setupGL(){\n  var webGL;\n  webGL = new WebGL_0;\n  this.gl = webGL;\n  this.engine = new Engine_0(this.gl, new SynchronousTaskRunner_0);\n  $resize(this, getCanvasWidth(webGL.canvasElementId), getCanvasHeight(webGL.canvasElementId));\n  dynamicCast($get_0(allDemos(), this.currentDemo), Q$Demo).setup(this.engine);\n}\n;\n_.update_0 = function update_2(ellapsedTimeMs){\n  $update(this.engine, fromDouble(ellapsedTimeMs));\n}\n;\n_.canvasHeight = 0;\n_.currentDemo = 0;\nvar TAG_2;\nfunction $glBindBuffer(this$static, target, buffer){\n  glBindBuffer(this$static.gl, target, $getBuffer(this$static.webGLObjects, buffer));\n}\n\nfunction $glBlendFunc(this$static, sfactor, dfactor){\n  glBlendFunc(this$static.gl, sfactor, dfactor);\n}\n\nfunction $glBufferData(this$static, target, nativeBuffer, usage){\n  glBufferData(this$static.gl, target, nativeBuffer.nativeArray, usage);\n}\n\nfunction $glBufferSubData(this$static, target, nativeBuffer){\n  glBufferSubData(this$static.gl, target, 0, nativeBuffer.nativeArray);\n}\n\nfunction $glClear(this$static, mask){\n  glClear(this$static.gl, mask);\n}\n\nfunction $glDrawArrays(this$static, mode, count){\n  glDrawArrays(this$static.gl, mode, 0, count);\n}\n\nfunction $glEnable(this$static, cap){\n  glEnable(this$static.gl, cap);\n}\n\nfunction $glEnableVertexAttribArray(this$static, glLocation){\n  glEnableVertexAttribArray(this$static.gl, glLocation);\n}\n\nfunction $glGetAttribLocation(this$static, program, attribute){\n  return glGetAttribLocation(this$static.gl, $getProgram(this$static.webGLObjects, program), attribute);\n}\n\nfunction $glGetProgramiv(this$static, program, pname, params){\n  params[0] = glProgramParameter(this$static.gl, $getProgram(this$static.webGLObjects, program), pname);\n}\n\nfunction $glGetShaderiv(this$static, shader, pname, params){\n  params[0] = glShaderParameter(this$static.gl, $getShader(this$static.webGLObjects, shader), pname);\n}\n\nfunction $glGetUniformLocation(this$static, program, uniform){\n  return $addUniformLocation(this$static.webGLObjects, glGetUniformLocation(this$static.gl, $getProgram(this$static.webGLObjects, program), uniform));\n}\n\nfunction $glLineWidth(this$static, width_0){\n  glLineWidth(this$static.gl, width_0);\n}\n\nfunction $glUniform4f(this$static, glLocation, x_0, y_0, z_0, w){\n  glUniform4f(this$static.gl, $getUniformLocation(this$static.webGLObjects, glLocation), x_0, y_0, z_0, w);\n}\n\nfunction $glUniformMatrix4(this$static, glLocation, mat){\n  var uniform;\n  uniform = $getUniformLocation(this$static.webGLObjects, glLocation);\n  glUniformMatrix4fv(this$static.gl, uniform, mat);\n}\n\nfunction $glUseProgram(this$static, program){\n  glUseProgram(this$static.gl, $getProgram(this$static.webGLObjects, program));\n}\n\nfunction $glVertexAttribPointer(this$static, glLocation, size_0, stride, offset){\n  glVertexAttribPointer(this$static.gl, glLocation, size_0, false, stride, offset);\n}\n\nfunction $glViewport(this$static, width_0, height){\n  glViewport(this$static.gl, 0, 0, width_0, height);\n}\n\nfunction WebGL_0(){\n  this.gl = glContext('graph-canvas', true);\n  this.canvasElementId = 'graph-canvas';\n  this.webGLObjects = new WebGLObjects_0;\n}\n\nfunction getCanvasHeight(canvasElementId){\n  var canvas = $doc.getElementById(canvasElementId);\n  return canvas.height;\n}\n\nfunction getCanvasWidth(canvasElementId){\n  var canvas = $doc.getElementById(canvasElementId);\n  return canvas.width;\n}\n\nfunction glAttachShader(gl, program, shader){\n  gl.attachShader(program, shader);\n}\n\nfunction glBindBuffer(gl, target, buffer){\n  gl.bindBuffer(target, buffer);\n}\n\nfunction glBlendFunc(gl, sfactor, dfactor){\n  gl.blendFunc(sfactor, dfactor);\n}\n\nfunction glBufferData(gl, target, nativeArray, usage){\n  gl.bufferData(target, nativeArray, usage);\n}\n\nfunction glBufferSubData(gl, target, offset, nativeArray){\n  gl.bufferSubData(target, offset, nativeArray);\n}\n\nfunction glClear(gl, mask){\n  gl.clear(mask);\n}\n\nfunction glCompileShader(gl, shaderProgram){\n  gl.compileShader(shaderProgram);\n}\n\nfunction glContext(canvasElementId, debugMode){\n  try {\n    var canvas = $doc.getElementById(canvasElementId);\n    var ctx = canvas.getContext('webgl', {antialias:true}) || canvas.getContext('experimental-webgl', {antialias:true});\n    try {\n      debugMode && $wnd.WebGLDebugUtils.init(ctx);\n    }\n     catch (e) {\n      alert('Warning: Could not initialise debug for WebGL.');\n    }\n    return ctx;\n  }\n   catch (e) {\n    alert('Could not initialise WebGL, sorry :-(');\n    return null;\n  }\n}\n\nfunction glCreateShader(gl, shaderType){\n  return gl.createShader(shaderType);\n}\n\nfunction glDrawArrays(gl, mode, first, count){\n  gl.drawArrays(mode, first, count);\n}\n\nfunction glEnable(gl, cap){\n  gl.enable(cap);\n}\n\nfunction glEnableVertexAttribArray(gl, glLocation){\n  gl.enableVertexAttribArray(glLocation);\n}\n\nfunction glGetAttribLocation(gl, program, attribute){\n  return gl.getAttribLocation(program, attribute);\n}\n\nfunction glGetUniformLocation(gl, program, uniform){\n  return gl.getUniformLocation(program, uniform);\n}\n\nfunction glLineWidth(gl, width_0){\n  gl.lineWidth(width_0);\n}\n\nfunction glLinkProgram(gl, program){\n  gl.linkProgram(program);\n}\n\nfunction glProgramInfoLog(gl, program){\n  return gl.getProgramInfoLog(program);\n}\n\nfunction glProgramParameter(gl, program, pname){\n  return gl.getProgramParameter(program, pname);\n}\n\nfunction glShaderInfoLog(gl, shader){\n  return gl.getShaderInfoLog(shader);\n}\n\nfunction glShaderParameter(gl, shaderProgram, pname){\n  return gl.getShaderParameter(shaderProgram, pname);\n}\n\nfunction glShaderSource(gl, shaderProgram, shaderCode){\n  gl.shaderSource(shaderProgram, shaderCode);\n}\n\nfunction glUniform4f(gl, glLocation, x_0, y_0, z_0, w){\n  gl.uniform4f(glLocation, x_0, y_0, z_0, w);\n}\n\nfunction glUniformMatrix4fv(gl, uniform, mat){\n  gl.uniformMatrix4fv(uniform, false, mat);\n}\n\nfunction glUseProgram(gl, program){\n  gl.useProgram(program);\n}\n\nfunction glValidateProgram(gl, program){\n  gl.validateProgram(program);\n}\n\nfunction glVertexAttribPointer(gl, glLocation, size_0, normalized, stride, offset){\n  gl.vertexAttribPointer(glLocation, size_0, gl.FLOAT, normalized, stride, offset);\n}\n\nfunction glViewport(gl, x_0, y_0, width_0, height){\n  gl.viewport(x_0, y_0, width_0, height);\n}\n\ndefineSeed(72, 1, {}, WebGL_0);\nfunction $clinit_WebGLObjects(){\n  $clinit_WebGLObjects = nullMethod;\n  logger_0 = ($clinit_Logger() , $getLoggerHelper(Lcom_github_rma350_jgraphv_web_client_coredeps_WebGLObjects_2_classLit.simpleName));\n}\n\nfunction $addBuffer(this$static, buffer){\n  $add_1(this$static.buffers, buffer);\n  checkSize(this$static.objects, Lcom_google_gwt_core_client_JavaScriptObject_2_classLit.simpleName);\n  return this$static.buffers.size_0 - 1;\n}\n\nfunction $addProgram(this$static, program){\n  $add_1(this$static.programs, program);\n  checkSize(this$static.objects, Lcom_google_gwt_core_client_JavaScriptObject_2_classLit.simpleName);\n  return this$static.programs.size_0 - 1;\n}\n\nfunction $addShader(this$static, shader){\n  $add_1(this$static.shaders, shader);\n  checkSize(this$static.objects, Lcom_google_gwt_core_client_JavaScriptObject_2_classLit.simpleName);\n  return this$static.shaders.size_0 - 1;\n}\n\nfunction $addUniformLocation(this$static, uniformLocation){\n  $add_1(this$static.uniformLocations, uniformLocation);\n  checkSize(this$static.objects, Lcom_google_gwt_core_client_JavaScriptObject_2_classLit.simpleName);\n  return this$static.uniformLocations.size_0 - 1;\n}\n\nfunction $getBuffer(this$static, index_0){\n  return dynamicCastJso($get_0(this$static.buffers, index_0));\n}\n\nfunction $getProgram(this$static, index_0){\n  return dynamicCastJso($get_0(this$static.programs, index_0));\n}\n\nfunction $getShader(this$static, index_0){\n  return dynamicCastJso($get_0(this$static.shaders, index_0));\n}\n\nfunction $getUniformLocation(this$static, index_0){\n  return dynamicCastJso($get_0(this$static.uniformLocations, index_0));\n}\n\nfunction WebGLObjects_0(){\n  $clinit_WebGLObjects();\n  this.objects = new ArrayList_0;\n  this.buffers = new ArrayList_0;\n  new ArrayList_0;\n  this.programs = new ArrayList_0;\n  new ArrayList_0;\n  this.shaders = new ArrayList_0;\n  new ArrayList_0;\n  this.uniformLocations = new ArrayList_0;\n}\n\nfunction checkSize(list, className){\n  list.size_0 > 500 && $log_1(logger_0, ($clinit_Level() , WARNING), 'Created ' + list.size_0 + ' unique ' + className + \", you probably don't want to do this.\");\n}\n\ndefineSeed(73, 1, {}, WebGLObjects_0);\nvar logger_0;\nfunction equals__devirtual$(this$static, other){\n  var maybeJsoInvocation;\n  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.equals$(other):maybeJsoInvocation === other;\n}\n\nfunction hashCode__devirtual$(this$static){\n  var maybeJsoInvocation;\n  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.hashCode$():getHashCode(maybeJsoInvocation);\n}\n\nfunction nCreateMat4(){\n  return $wnd.mat4.create();\n}\n\nfunction nCreateVec4(x_0, y_0, z_0, w){\n  var ans = $wnd.vec4.create();\n  ans[0] = x_0;\n  ans[1] = y_0;\n  ans[2] = z_0;\n  ans[3] = w;\n  return ans;\n}\n\nfunction nInvert(mat){\n  var ans = $wnd.mat4.create();\n  $wnd.mat4.invert(ans, mat);\n  return ans;\n}\n\nfunction nMult(mat, vec){\n  var ans = $wnd.vec4.create();\n  $wnd.vec4.transformMat4(ans, vec, mat);\n  return ans;\n}\n\nfunction nScale(mat, scaleX, scaleY){\n  $wnd.mat4.scale(mat, mat, [scaleX, scaleY, 1]);\n}\n\nfunction nSetIdentity(mat){\n  $wnd.mat4.identity(mat);\n}\n\nfunction nSetOrtho2D(mat, left, right, bottom, top_0){\n  $wnd.mat4.ortho(mat, left, right, bottom, top_0, -1, 1);\n}\n\nfunction nTranslate(mat, dX, dY){\n  $wnd.mat4.translate(mat, mat, [dX, dY, 0]);\n}\n\nfunction $putAll(this$static, values){\n  $set_0(this$static.nativeArray, values, 0);\n}\n\nfunction $putAll_0(this$static, src_0, srcFloatCount){\n  var srcExact;\n  srcExact = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, srcFloatCount, 1);\n  arraycopy(src_0, 0, srcExact, 0, srcFloatCount);\n  $set_0(this$static.nativeArray, srcExact, 0);\n}\n\nfunction WebNativeFloatBuffer_0(sizeInFloats){\n  this.nativeArray = new Float32Array(sizeInFloats);\n}\n\ndefineSeed(81, 1, {}, WebNativeFloatBuffer_0);\nfunction setUncaughtExceptionHandler(handler){\n  uncaughtExceptionHandler = handler;\n}\n\nvar uncaughtExceptionHandler = null;\nfunction $getStackTrace(this$static){\n  if (this$static.stackTrace == null) {\n    return initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable]), Q$StackTraceElement, 0, 0);\n  }\n  return this$static.stackTrace;\n}\n\nfunction $initCause(this$static, cause){\n  if (this$static.cause) {\n    throw new IllegalStateException_1(\"Can't overwrite cause\");\n  }\n  if (cause == this$static) {\n    throw new IllegalArgumentException_0('Self-causation not permitted');\n  }\n  this$static.cause = cause;\n  return this$static;\n}\n\nfunction $printStackTrace(this$static, out){\n  var element, element$array, element$index, element$max, t;\n  for (t = this$static; t; t = t.cause) {\n    t != this$static && out.append('Caused by: ');\n    out.append('' + t);\n    out.newLine();\n    for (element$array = $getStackTrace(t) , element$index = 0 , element$max = element$array.length; element$index < element$max; ++element$index) {\n      element = element$array[element$index];\n      out.append('\\tat ' + element);\n      out.newLine();\n    }\n  }\n}\n\nfunction $setStackTrace(this$static, stackTrace){\n  var c, copy, i;\n  copy = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable]), Q$StackTraceElement, stackTrace.length, 0);\n  for (i = 0 , c = stackTrace.length; i < c; ++i) {\n    if (!stackTrace[i]) {\n      throw new NullPointerException_0;\n    }\n    copy[i] = stackTrace[i];\n  }\n  this$static.stackTrace = copy;\n}\n\nfunction Throwable_0(message){\n  this.detailMessage = message;\n  this.fillInStackTrace();\n}\n\ndefineSeed(88, 1, makeCastMap([Q$Serializable, Q$Throwable]));\n_.fillInStackTrace = function fillInStackTrace(){\n  $fillInStackTrace(this);\n  return this;\n}\n;\n_.getMessage = function getMessage(){\n  return this.detailMessage;\n}\n;\n_.toString$ = function toString_4(){\n  var className, msg;\n  className = this.___clazz$.typeName;\n  msg = this.getMessage();\n  return msg != null?className + ': ' + msg:className;\n}\n;\ndefineSeed(87, 88, makeCastMap([Q$Serializable, Q$Throwable]));\nfunction RuntimeException_0(){\n  this.fillInStackTrace();\n}\n\nfunction RuntimeException_1(message){\n  Throwable_0.call(this, message);\n}\n\ndefineSeed(86, 87, makeCastMap([Q$Serializable, Q$Throwable]), RuntimeException_1);\nfunction $clinit_JavaScriptException(){\n  $clinit_JavaScriptException = nullMethod;\n  NOT_SET = new Object_1;\n}\n\nfunction $ensureInit(this$static){\n  var exception, maybeJsoInvocation;\n  if (this$static.message_0 == null) {\n    exception = this$static.e === NOT_SET?null:this$static.e;\n    this$static.name_0 = exception == null?'null':instanceOfJso(exception)?getExceptionName0(dynamicCastJso(exception)):instanceOf(exception, Q$String)?'String':(maybeJsoInvocation = exception , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.___clazz$:Lcom_google_gwt_core_client_JavaScriptObject_2_classLit).typeName;\n    this$static.description = this$static.description + ': ' + (instanceOfJso(exception)?getExceptionDescription0(dynamicCastJso(exception)):exception + '');\n    this$static.message_0 = '(' + this$static.name_0 + ') ' + (instanceOfJso(exception)?$getProperties(dynamicCastJso(exception)):'') + this$static.description;\n  }\n}\n\nfunction JavaScriptException_0(e){\n  $clinit_JavaScriptException();\n  RuntimeException_0.call(this);\n  this.description = '';\n  this.e = e;\n  this.description = '';\n  $createStackTrace(this);\n}\n\nfunction getExceptionDescription0(e){\n  return e == null?null:e.message;\n}\n\nfunction getExceptionName0(e){\n  return e == null?null:e.name;\n}\n\ndefineSeed(85, 86, makeCastMap([Q$JavaScriptException, Q$Serializable, Q$Throwable]), JavaScriptException_0);\n_.getMessage = function getMessage_0(){\n  $ensureInit(this);\n  return this.message_0;\n}\n;\n_.getThrown = function getThrown(){\n  return this.e === NOT_SET?null:this.e;\n}\n;\nvar NOT_SET;\n",
"function $push(this$static, value_0){\n  this$static[this$static.length] = value_0;\n}\n\nfunction create(milliseconds){\n  return new Date(milliseconds);\n}\n\ndefineSeed(93, 1, {});\nfunction apply_0(jsFunction, thisObj, args){\n  return jsFunction.apply(thisObj, args);\n  var __0;\n}\n\nfunction dispose(d){\n}\n\nfunction enter(){\n  var now_0;\n  if (entryDepth != 0) {\n    now_0 = (new Date).getTime();\n    if (now_0 - watchdogEntryDepthLastScheduled > 2000) {\n      watchdogEntryDepthLastScheduled = now_0;\n      watchdogEntryDepthTimerId = watchdogEntryDepthSchedule();\n    }\n  }\n  if (entryDepth++ == 0) {\n    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE));\n    return true;\n  }\n  return false;\n}\n\nfunction entry_0(jsFunction){\n  return function(){\n    try {\n      return entry0(jsFunction, this, arguments);\n    }\n     catch (e) {\n      throw e;\n    }\n  }\n  ;\n}\n\nfunction entry0(jsFunction, thisObj, args){\n  var initialEntry, t;\n  initialEntry = enter();\n  try {\n    if (uncaughtExceptionHandler) {\n      try {\n        return apply_0(jsFunction, thisObj, args);\n      }\n       catch ($e0) {\n        $e0 = wrap($e0);\n        if (instanceOf($e0, Q$Throwable)) {\n          t = $e0;\n          reportUncaughtException(t);\n          return undefined;\n        }\n         else \n          throw unwrap($e0);\n      }\n    }\n     else {\n      return apply_0(jsFunction, thisObj, args);\n    }\n  }\n   finally {\n    exit(initialEntry);\n  }\n}\n\nfunction exit(initialEntry){\n  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE));\n  --entryDepth;\n  if (initialEntry) {\n    if (watchdogEntryDepthTimerId != -1) {\n      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);\n      watchdogEntryDepthTimerId = -1;\n    }\n  }\n}\n\nfunction getHashCode(o){\n  return o.$H || (o.$H = ++sNextHashId);\n}\n\nfunction registerEntry(){\n  return entry_0;\n}\n\nfunction reportToBrowser(e){\n  $wnd.setTimeout(function(){\n    throw e;\n  }\n  , 0);\n}\n\nfunction reportUncaughtException(e){\n  var handler;\n  handler = uncaughtExceptionHandler;\n  if (handler) {\n    if (handler == uncaughtExceptionHandlerForTest) {\n      return;\n    }\n    $log_2(handler.val$log, ($clinit_Level() , SEVERE), e.getMessage(), e);\n    return;\n  }\n  reportToBrowser(instanceOf(e, Q$JavaScriptException)?dynamicCast(e, Q$JavaScriptException).getThrown():e);\n}\n\nfunction setTimeout_0(func, time){\n  return setTimeout0(func, time, null);\n}\n\nfunction watchdogEntryDepthCancel(timerId){\n  $wnd.clearTimeout(timerId);\n}\n\nfunction watchdogEntryDepthSchedule(){\n  return setTimeout_0(function(){\n    entryDepth != 0 && (entryDepth = 0);\n    watchdogEntryDepthTimerId = -1;\n  }\n  , 10);\n}\n\nvar entryDepth = 0, sNextHashId = 0, uncaughtExceptionHandlerForTest, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;\nfunction $clinit_SchedulerImpl(){\n  $clinit_SchedulerImpl = nullMethod;\n  INSTANCE = new SchedulerImpl_0;\n}\n\nfunction $flushEntryCommands(this$static){\n  var oldQueue, rescheduled;\n  if (this$static.entryCommands) {\n    rescheduled = null;\n    do {\n      oldQueue = this$static.entryCommands;\n      this$static.entryCommands = null;\n      rescheduled = runScheduledTasks(oldQueue, rescheduled);\n    }\n     while (this$static.entryCommands);\n    this$static.entryCommands = rescheduled;\n  }\n}\n\nfunction $flushFinallyCommands(this$static){\n  var oldQueue, rescheduled;\n  if (this$static.finallyCommands) {\n    rescheduled = null;\n    do {\n      oldQueue = this$static.finallyCommands;\n      this$static.finallyCommands = null;\n      rescheduled = runScheduledTasks(oldQueue, rescheduled);\n    }\n     while (this$static.finallyCommands);\n    this$static.finallyCommands = rescheduled;\n  }\n}\n\nfunction SchedulerImpl_0(){\n}\n\nfunction push_0(queue, task){\n  !queue && (queue = []);\n  queue[queue.length] = task;\n  return queue;\n}\n\nfunction runScheduledTasks(tasks, rescheduled){\n  var e, i, j, t;\n  for (i = 0 , j = tasks.length; i < j; i++) {\n    t = tasks[i];\n    try {\n      t[1]?t[0].nullMethod() && (rescheduled = push_0(rescheduled, t)):t[0].nullMethod();\n    }\n     catch ($e0) {\n      $e0 = wrap($e0);\n      if (instanceOf($e0, Q$Throwable)) {\n        e = $e0;\n        reportUncaughtException(e);\n      }\n       else \n        throw unwrap($e0);\n    }\n  }\n  return rescheduled;\n}\n\ndefineSeed(95, 93, {}, SchedulerImpl_0);\nvar INSTANCE;\nfunction extractNameFromToString(fnToString){\n  var index_0, start_0, toReturn;\n  toReturn = '';\n  fnToString = $trim(fnToString);\n  index_0 = fnToString.indexOf('(');\n  start_0 = fnToString.indexOf('function') == 0?8:0;\n  if (index_0 == -1) {\n    index_0 = $indexOf(fnToString, fromCodePoint(64));\n    start_0 = fnToString.indexOf('function ') == 0?9:0;\n  }\n  index_0 != -1 && (toReturn = $trim($substring_0(fnToString, start_0, index_0)));\n  return toReturn.length > 0?toReturn:'anonymous';\n}\n\nfunction splice(arr, length_0){\n  arr.length >= length_0 && arr.splice(0, length_0);\n  return arr;\n}\n\nfunction $createStackTrace(e){\n  var i, j, stack_0, stackTrace;\n  stack_0 = $inferFrom(e.e === ($clinit_JavaScriptException() , NOT_SET)?null:e.e);\n  stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable]), Q$StackTraceElement, stack_0.length, 0);\n  for (i = 0 , j = stackTrace.length; i < j; i++) {\n    stackTrace[i] = new StackTraceElement_0(stack_0[i]);\n  }\n  $setStackTrace(e, stackTrace);\n}\n\nfunction $fillInStackTrace(t){\n  var i, j, stack_0, stackTrace;\n  stack_0 = splice($inferFrom($makeException()), 2);\n  stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable]), Q$StackTraceElement, stack_0.length, 0);\n  for (i = 0 , j = stackTrace.length; i < j; i++) {\n    stackTrace[i] = new StackTraceElement_0(stack_0[i]);\n  }\n  $setStackTrace(t, stackTrace);\n}\n\nfunction $getProperties(e){\n  var result = '';\n  try {\n    for (var prop in e) {\n      if (prop != 'name' && prop != 'message' && prop != 'toString') {\n        try {\n          var propValue = prop != '__gwt$exception'?e[prop]:'<skipped>';\n          result += '\\n ' + prop + ': ' + propValue;\n        }\n         catch (ignored) {\n        }\n      }\n    }\n  }\n   catch (ignored) {\n  }\n  return result;\n}\n\nfunction $makeException(){\n  try {\n    null.a();\n  }\n   catch (e) {\n    return e;\n  }\n}\n\nfunction $inferFrom(e){\n  var i, j, jso, stack_0;\n  jso = instanceOfJso(e)?dynamicCastJso(e):null;\n  stack_0 = jso && jso.stack?jso.stack.split('\\n'):[];\n  for (i = 0 , j = stack_0.length; i < j; i++) {\n    stack_0[i] = extractNameFromToString(stack_0[i]);\n  }\n  return stack_0;\n}\n\ndefineSeed(100, 1, {});\nfunction $append(this$static, x_0){\n  this$static.string += x_0;\n}\n\nfunction StringBufferImplAppend_0(){\n}\n\ndefineSeed(101, 100, {}, StringBufferImplAppend_0);\n_.string = '';\nfunction setTimeout0(func, time, disposeable){\n  var timerId = $wnd.setTimeout(function(){\n    func();\n    disposeable != null && dispose(disposeable);\n  }\n  , time);\n  return timerId;\n}\n\nfunction $initCause_0(this$static, cause){\n  return $initCause(this$static, instanceOf(cause, Q$SerializableThrowable)?dynamicCast(cause, Q$SerializableThrowable):cause?createSerializable(cause):null);\n}\n\nfunction $setDesignatedType(this$static, typeName){\n  this$static.typeName = typeName;\n  this$static.exactTypeKnown = true;\n}\n\nfunction SerializableThrowable_0(message){\n  Throwable_0.call(this, message);\n  this.typeName = null;\n}\n\nfunction createSerializable(t){\n  var throwable;\n  throwable = new SerializableThrowable_0(t.getMessage());\n  $setStackTrace(throwable, $getStackTrace(t));\n  $initCause_0(throwable, t.cause);\n  $setDesignatedType(throwable, t.___clazz$.typeName);\n  return throwable;\n}\n\ndefineSeed(103, 88, makeCastMap([Q$SerializableThrowable, Q$Serializable, Q$Throwable]), SerializableThrowable_0);\n_.fillInStackTrace = function fillInStackTrace_0(){\n  return this;\n}\n;\n_.toString$ = function toString_5(){\n  var msg, type_0;\n  type_0 = this.exactTypeKnown?this.typeName:this.typeName + '(EXACT TYPE UNKNOWN)';\n  msg = this.detailMessage;\n  return msg == null?type_0:type_0 + ': ' + msg;\n}\n;\n_.exactTypeKnown = false;\nfunction $setInnerText(elem, text_0){\n  elem.textContent = text_0 || '';\n}\n\nfunction $eventGetRelatedTarget(evt){\n  var relatedTarget = evt.relatedTarget;\n  if (!relatedTarget) {\n    return null;\n  }\n  try {\n    var nodeName = relatedTarget.nodeName;\n    return relatedTarget;\n  }\n   catch (e) {\n    return null;\n  }\n}\n\nfunction $isOrHasChild(parent_0, child){\n  return parent_0 === child || !!(parent_0.compareDocumentPosition(child) & 16);\n}\n\nfunction $toString(elem){\n  var doc = elem.ownerDocument;\n  var temp = elem.cloneNode(true);\n  var tempDiv = doc.createElement('DIV');\n  tempDiv.appendChild(temp);\n  outer = tempDiv.innerHTML;\n  temp.innerHTML = '';\n  return outer;\n}\n\nfunction $setClassName(this$static, className){\n  this$static.className = className;\n}\n\nfunction $setInnerHTML(this$static, html){\n  this$static.innerHTML = html || '';\n}\n\nfunction $setPropertyString(this$static, name_0, value_0){\n  this$static[name_0] = value_0;\n}\n\nfunction $clinit_Style$TextAlign(){\n  $clinit_Style$TextAlign = nullMethod;\n  CENTER = new Style$TextAlign$1_0;\n  JUSTIFY = new Style$TextAlign$2_0;\n  LEFT = new Style$TextAlign$3_0;\n  RIGHT = new Style$TextAlign$4_0;\n  $VALUES_0 = initValues(_3Lcom_google_gwt_dom_client_Style$TextAlign_2_classLit, makeCastMap([Q$Serializable]), Q$Style$TextAlign, [CENTER, JUSTIFY, LEFT, RIGHT]);\n}\n\nfunction Style$TextAlign_0(enum$name, enum$ordinal){\n  Enum_0.call(this, enum$name, enum$ordinal);\n}\n\nfunction values_1(){\n  $clinit_Style$TextAlign();\n  return $VALUES_0;\n}\n\ndefineSeed(112, 64, makeCastMap([Q$Style$HasCssName, Q$Style$TextAlign, Q$Serializable, Q$Comparable, Q$Enum]));\nvar $VALUES_0, CENTER, JUSTIFY, LEFT, RIGHT;\nfunction Style$TextAlign$1_0(){\n  Style$TextAlign_0.call(this, 'CENTER', 0);\n}\n\ndefineSeed(113, 112, makeCastMap([Q$Style$HasCssName, Q$Style$TextAlign, Q$Serializable, Q$Comparable, Q$Enum]), Style$TextAlign$1_0);\nfunction Style$TextAlign$2_0(){\n  Style$TextAlign_0.call(this, 'JUSTIFY', 1);\n}\n\ndefineSeed(114, 112, makeCastMap([Q$Style$HasCssName, Q$Style$TextAlign, Q$Serializable, Q$Comparable, Q$Enum]), Style$TextAlign$2_0);\nfunction Style$TextAlign$3_0(){\n  Style$TextAlign_0.call(this, 'LEFT', 2);\n}\n\ndefineSeed(115, 112, makeCastMap([Q$Style$HasCssName, Q$Style$TextAlign, Q$Serializable, Q$Comparable, Q$Enum]), Style$TextAlign$3_0);\nfunction Style$TextAlign$4_0(){\n  Style$TextAlign_0.call(this, 'RIGHT', 3);\n}\n\ndefineSeed(116, 112, makeCastMap([Q$Style$HasCssName, Q$Style$TextAlign, Q$Serializable, Q$Comparable, Q$Enum]), Style$TextAlign$4_0);\nfunction fireNativeEvent(){\n}\n\nfunction throwIfNull(value_0){\n  if (null == value_0) {\n    throw new NullPointerException_1('encodedURLComponent cannot be null');\n  }\n}\n\nfunction getDirectionOnElement(elem){\n  var dirPropertyValue;\n  dirPropertyValue = elem['dir'] == null?null:String(elem['dir']);\n  if ($equalsIgnoreCase('rtl', dirPropertyValue)) {\n    return $clinit_HasDirection$Direction() , RTL;\n  }\n   else if ($equalsIgnoreCase('ltr', dirPropertyValue)) {\n    return $clinit_HasDirection$Direction() , LTR;\n  }\n  return $clinit_HasDirection$Direction() , DEFAULT;\n}\n\nfunction setDirectionOnElement(elem, direction){\n  switch (direction.ordinal) {\n    case 0:\n      {\n        $setPropertyString(elem, 'dir', 'rtl');\n        break;\n      }\n\n    case 1:\n      {\n        $setPropertyString(elem, 'dir', 'ltr');\n        break;\n      }\n\n    case 2:\n      {\n        getDirectionOnElement(elem) != ($clinit_HasDirection$Direction() , DEFAULT) && $setPropertyString(elem, 'dir', '');\n        break;\n      }\n\n  }\n}\n\nfunction $clinit_HasDirection$Direction(){\n  $clinit_HasDirection$Direction = nullMethod;\n  RTL = new HasDirection$Direction_0('RTL', 0);\n  LTR = new HasDirection$Direction_0('LTR', 1);\n  DEFAULT = new HasDirection$Direction_0('DEFAULT', 2);\n  $VALUES_1 = initValues(_3Lcom_google_gwt_i18n_client_HasDirection$Direction_2_classLit, makeCastMap([Q$Serializable]), Q$HasDirection$Direction, [RTL, LTR, DEFAULT]);\n}\n\nfunction HasDirection$Direction_0(enum$name, enum$ordinal){\n  Enum_0.call(this, enum$name, enum$ordinal);\n}\n\nfunction values_2(){\n  $clinit_HasDirection$Direction();\n  return $VALUES_1;\n}\n\ndefineSeed(123, 64, makeCastMap([Q$HasDirection$Direction, Q$Serializable, Q$Comparable, Q$Enum]), HasDirection$Direction_0);\nvar $VALUES_1, DEFAULT, LTR, RTL;\nfunction Array_0(){\n}\n\nfunction createFrom(array, length_0){\n  var a, result;\n  a = array;\n  result = createFromSeed(0, length_0);\n  initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result);\n  return result;\n}\n\nfunction createFromSeed(seedType, length_0){\n  var array = new Array(length_0);\n  if (seedType == 3) {\n    for (var i = 0; i < length_0; ++i) {\n      array[i] = {l:0, m:0, h:0};\n    }\n  }\n   else if (seedType > 0 && seedType < 3) {\n    var value_0 = seedType == 1?0:false;\n    for (var i = 0; i < length_0; ++i) {\n      array[i] = value_0;\n    }\n  }\n  return array;\n}\n\nfunction initDim(arrayClass, castableTypeMap, queryId, length_0, seedType){\n  var result;\n  result = createFromSeed(seedType, length_0);\n  initValues(arrayClass, castableTypeMap, queryId, result);\n  return result;\n}\n\nfunction initValues(arrayClass, castableTypeMap, queryId, array){\n  $clinit_Array$ExpandoWrapper();\n  wrapArray(array, expandoNames_0, expandoValues_0);\n  array.___clazz$ = arrayClass;\n  array.castableTypeMap$ = castableTypeMap;\n  array.queryId$ = queryId;\n  return array;\n}\n\nfunction setCheck(array, index_0, value_0){\n  if (value_0 != null) {\n    if (array.queryId$ > 0 && !canCastUnsafe(value_0, array.queryId$)) {\n      throw new ArrayStoreException_0;\n    }\n     else if (array.queryId$ == -1 && (value_0.typeMarker$ == nullMethod || canCast(value_0, 1))) {\n      throw new ArrayStoreException_0;\n    }\n     else if (array.queryId$ < -1 && !(value_0.typeMarker$ != nullMethod && !canCast(value_0, 1)) && !canCastUnsafe(value_0, -array.queryId$)) {\n      throw new ArrayStoreException_0;\n    }\n  }\n  return array[index_0] = value_0;\n}\n\ndefineSeed(124, 1, {}, Array_0);\n_.queryId$ = 0;\nfunction $clinit_Array$ExpandoWrapper(){\n  $clinit_Array$ExpandoWrapper = nullMethod;\n  expandoNames_0 = [];\n  expandoValues_0 = [];\n  initExpandos(new Array_0, expandoNames_0, expandoValues_0);\n}\n\nfunction initExpandos(protoType, expandoNames, expandoValues){\n  var i = 0, value_0;\n  for (var name_0 in protoType) {\n    if (value_0 = protoType[name_0]) {\n      expandoNames[i] = name_0;\n      expandoValues[i] = value_0;\n      ++i;\n    }\n  }\n}\n\nfunction wrapArray(array, expandoNames, expandoValues){\n  $clinit_Array$ExpandoWrapper();\n  for (var i = 0, c = expandoNames.length; i < c; ++i) {\n    array[expandoNames[i]] = expandoValues[i];\n  }\n}\n\nvar expandoNames_0, expandoValues_0;\nfunction canCast(src_0, dstId){\n  return src_0.castableTypeMap$ && !!src_0.castableTypeMap$[dstId];\n}\n\nfunction canCastUnsafe(src_0, dstId){\n  return src_0.castableTypeMap$ && src_0.castableTypeMap$[dstId];\n}\n\nfunction dynamicCast(src_0, dstId){\n  if (src_0 != null && !canCastUnsafe(src_0, dstId)) {\n    throw new ClassCastException_0;\n  }\n  return src_0;\n}\n\nfunction dynamicCastJso(src_0){\n  if (src_0 != null && (src_0.typeMarker$ == nullMethod || canCast(src_0, 1))) {\n    throw new ClassCastException_0;\n  }\n  return src_0;\n}\n\nfunction instanceOf(src_0, dstId){\n  return src_0 != null && canCast(src_0, dstId);\n}\n\nfunction instanceOfJso(src_0){\n  return src_0 != null && src_0.typeMarker$ != nullMethod && !canCast(src_0, 1);\n}\n\nfunction isJavaObject(src_0){\n  return src_0.typeMarker$ == nullMethod || canCast(src_0, 1);\n}\n\nfunction maskUndefined(src_0){\n  return src_0 == null?null:src_0;\n}\n\nfunction round_int(x_0){\n  return ~~Math.max(Math.min(x_0, 2147483647), -2147483648);\n}\n\nfunction init(){\n  var runtimeValue;\n  isStatsAvailable() && onModuleStart('com.google.gwt.useragent.client.UserAgentAsserter');\n  runtimeValue = $getRuntimeValue();\n  $equals('gecko1_8', runtimeValue) || ($wnd.alert('ERROR: Possible problem with your *.gwt.xml module file.\\nThe compile time user.agent value (gecko1_8) does not match the runtime user.agent value (' + runtimeValue + '). Expect more errors.\\n') , undefined);\n  isStatsAvailable() && onModuleStart('com.google.gwt.user.client.DocumentModeAsserter');\n  $onModuleLoad_0();\n  isStatsAvailable() && onModuleStart('com.google.gwt.logging.client.LogConfiguration');\n  $onModuleLoad($clinit_LogConfiguration());\n  isStatsAvailable() && onModuleStart('com.github.rma350.jgraphv.web.client.JGraphVWeb');\n  $publish(new JGraphVWeb_0);\n  $clinit_JGraphVWeb();\n  $wnd.onGWTModuleLoaded();\n}\n\nfunction getCachableJavaScriptException(e_0){\n  var jse = e_0.__gwt$exception;\n  if (!jse) {\n    jse = new JavaScriptException_0(e_0);\n    try {\n      e_0.__gwt$exception = jse;\n    }\n     catch (e) {\n    }\n  }\n  return jse;\n}\n\nfunction unwrap(e){\n  var jse;\n  if (instanceOf(e, Q$JavaScriptException)) {\n    jse = dynamicCast(e, Q$JavaScriptException);\n    if (jse.e !== ($clinit_JavaScriptException() , NOT_SET)) {\n      return jse.e === NOT_SET?null:jse.e;\n    }\n  }\n  return e;\n}\n\nfunction wrap(e){\n  if (instanceOf(e, Q$Throwable)) {\n    return e;\n  }\n  return e == null?new JavaScriptException_0(null):getCachableJavaScriptException(e);\n}\n\nfunction create_0(value_0){\n  var a0, a1, a2;\n  a0 = value_0 & 4194303;\n  a1 = value_0 >> 22 & 4194303;\n  a2 = value_0 < 0?1048575:0;\n  return create0(a0, a1, a2);\n}\n\nfunction create_1(a){\n  return create0(a.l, a.m, a.h);\n}\n\nfunction create0(l_0, m_0, h_0){\n  return {l:l_0, m:m_0, h:h_0};\n}\n\nfunction divMod(a, b, computeRemainder){\n  var aIsCopy, aIsMinValue, aIsNegative, bpower, c, negative;\n  if (b.l == 0 && b.m == 0 && b.h == 0) {\n    throw new ArithmeticException_0;\n  }\n  if (a.l == 0 && a.m == 0 && a.h == 0) {\n    computeRemainder && (remainder = create0(0, 0, 0));\n    return create0(0, 0, 0);\n  }\n  if (b.h == 524288 && b.m == 0 && b.l == 0) {\n    return divModByMinValue(a, computeRemainder);\n  }\n  negative = false;\n  if (b.h >> 19 != 0) {\n    b = neg(b);\n    negative = true;\n  }\n  bpower = powerOfTwo(b);\n  aIsNegative = false;\n  aIsMinValue = false;\n  aIsCopy = false;\n  if (a.h == 524288 && a.m == 0 && a.l == 0) {\n    aIsMinValue = true;\n    aIsNegative = true;\n    if (bpower == -1) {\n      a = create_1(($clinit_LongLib$Const() , MAX_VALUE));\n      aIsCopy = true;\n      negative = !negative;\n    }\n     else {\n      c = shr(a, bpower);\n      negative && negate(c);\n      computeRemainder && (remainder = create0(0, 0, 0));\n      return c;\n    }\n  }\n   else if (a.h >> 19 != 0) {\n    aIsNegative = true;\n    a = neg(a);\n    aIsCopy = true;\n    negative = !negative;\n  }\n  if (bpower != -1) {\n    return divModByShift(a, bpower, negative, aIsNegative, computeRemainder);\n  }\n  if (!gte_0(a, b)) {\n    computeRemainder && (aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h)));\n    return create0(0, 0, 0);\n  }\n  return divModHelper(aIsCopy?a:create0(a.l, a.m, a.h), b, negative, aIsNegative, aIsMinValue, computeRemainder);\n}\n\nfunction divModByMinValue(a, computeRemainder){\n  if (a.h == 524288 && a.m == 0 && a.l == 0) {\n    computeRemainder && (remainder = create0(0, 0, 0));\n    return create_1(($clinit_LongLib$Const() , ONE));\n  }\n  computeRemainder && (remainder = create0(a.l, a.m, a.h));\n  return create0(0, 0, 0);\n}\n\nfunction divModByShift(a, bpower, negative, aIsNegative, computeRemainder){\n  var c;\n  c = shr(a, bpower);\n  negative && negate(c);\n  if (computeRemainder) {\n    a = maskRight(a, bpower);\n    aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h));\n  }\n  return c;\n}\n\nfunction divModHelper(a, b, negative, aIsNegative, aIsMinValue, computeRemainder){\n  var bshift, gte, quotient, shift_0, a1, a2, a0;\n  shift_0 = numberOfLeadingZeros(b) - numberOfLeadingZeros(a);\n  bshift = shl(b, shift_0);\n  quotient = create0(0, 0, 0);\n  while (shift_0 >= 0) {\n    gte = trialSubtract(a, bshift);\n    if (gte) {\n      shift_0 < 22?(quotient.l |= 1 << shift_0 , undefined):shift_0 < 44?(quotient.m |= 1 << shift_0 - 22 , undefined):(quotient.h |= 1 << shift_0 - 44 , undefined);\n      if (a.l == 0 && a.m == 0 && a.h == 0) {\n        break;\n      }\n    }\n    a1 = bshift.m;\n    a2 = bshift.h;\n    a0 = bshift.l;\n    setH(bshift, a2 >>> 1);\n    bshift.m = a1 >>> 1 | (a2 & 1) << 21;\n    bshift.l = a0 >>> 1 | (a1 & 1) << 21;\n    --shift_0;\n  }\n  negative && negate(quotient);\n  if (computeRemainder) {\n    if (aIsNegative) {\n      remainder = neg(a);\n      aIsMinValue && (remainder = sub_0(remainder, ($clinit_LongLib$Const() , ONE)));\n    }\n     else {\n      remainder = create0(a.l, a.m, a.h);\n    }\n  }\n  return quotient;\n}\n\nfunction maskRight(a, bits){\n  var b0, b1, b2;\n  if (bits <= 22) {\n    b0 = a.l & (1 << bits) - 1;\n    b1 = b2 = 0;\n  }\n   else if (bits <= 44) {\n    b0 = a.l;\n    b1 = a.m & (1 << bits - 22) - 1;\n    b2 = 0;\n  }\n   else {\n    b0 = a.l;\n    b1 = a.m;\n    b2 = a.h & (1 << bits - 44) - 1;\n  }\n  return create0(b0, b1, b2);\n}\n\nfunction negate(a){\n  var neg0, neg1, neg2;\n  neg0 = ~a.l + 1 & 4194303;\n  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;\n  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;\n  setL(a, neg0);\n  setM(a, neg1);\n  setH(a, neg2);\n}\n\nfunction numberOfLeadingZeros(a){\n  var b1, b2;\n  b2 = numberOfLeadingZeros_0(a.h);\n  if (b2 == 32) {\n    b1 = numberOfLeadingZeros_0(a.m);\n    return b1 == 32?numberOfLeadingZeros_0(a.l) + 32:b1 + 20 - 10;\n  }\n   else {\n    return b2 - 12;\n  }\n}\n\nfunction powerOfTwo(a){\n  var h_0, l_0, m_0;\n  l_0 = a.l;\n  if ((l_0 & l_0 - 1) != 0) {\n    return -1;\n  }\n  m_0 = a.m;\n  if ((m_0 & m_0 - 1) != 0) {\n    return -1;\n  }\n  h_0 = a.h;\n  if ((h_0 & h_0 - 1) != 0) {\n    return -1;\n  }\n  if (h_0 == 0 && m_0 == 0 && l_0 == 0) {\n    return -1;\n  }\n  if (h_0 == 0 && m_0 == 0 && l_0 != 0) {\n    return numberOfTrailingZeros(l_0);\n  }\n  if (h_0 == 0 && m_0 != 0 && l_0 == 0) {\n    return numberOfTrailingZeros(m_0) + 22;\n  }\n  if (h_0 != 0 && m_0 == 0 && l_0 == 0) {\n    return numberOfTrailingZeros(h_0) + 44;\n  }\n  return -1;\n}\n\nfunction setH(a, x_0){\n  a.h = x_0;\n}\n\nfunction setL(a, x_0){\n  a.l = x_0;\n}\n\nfunction setM(a, x_0){\n  a.m = x_0;\n}\n\nfunction toDoubleHelper(a){\n  return a.l + a.m * 4194304 + a.h * 17592186044416;\n}\n\nfunction trialSubtract(a, b){\n  var sum0, sum1, sum2;\n  sum2 = a.h - b.h;\n  if (sum2 < 0) {\n    return false;\n  }\n  sum0 = a.l - b.l;\n  sum1 = a.m - b.m + (sum0 >> 22);\n  sum2 += sum1 >> 22;\n  if (sum2 < 0) {\n    return false;\n  }\n  setL(a, sum0 & 4194303);\n  setM(a, sum1 & 4194303);\n  setH(a, sum2 & 1048575);\n  return true;\n}\n\nvar remainder;\nfunction add_0(a, b){\n  var sum0, sum1, sum2;\n  sum0 = a.l + b.l;\n  sum1 = a.m + b.m + (sum0 >> 22);\n  sum2 = a.h + b.h + (sum1 >> 22);\n  return {l:sum0 & 4194303, m:sum1 & 4194303, h:sum2 & 1048575};\n}\n\nfunction eq(a, b){\n  return a.l == b.l && a.m == b.m && a.h == b.h;\n}\n\nfunction fromDouble(value_0){\n  var a0, a1, a2, negative, result;\n  if (isNaN(value_0)) {\n    return $clinit_LongLib$Const() , ZERO;\n  }\n  if (value_0 < -9223372036854775808) {\n    return $clinit_LongLib$Const() , MIN_VALUE;\n  }\n  if (value_0 >= 9223372036854775807) {\n    return $clinit_LongLib$Const() , MAX_VALUE;\n  }\n  negative = false;\n  if (value_0 < 0) {\n    negative = true;\n    value_0 = -value_0;\n  }\n  a2 = 0;\n  if (value_0 >= 17592186044416) {\n    a2 = round_int(value_0 / 17592186044416);\n    value_0 -= a2 * 17592186044416;\n  }\n  a1 = 0;\n  if (value_0 >= 4194304) {\n    a1 = round_int(value_0 / 4194304);\n    value_0 -= a1 * 4194304;\n  }\n  a0 = round_int(value_0);\n  result = create0(a0, a1, a2);\n  negative && negate(result);\n  return result;\n}\n\nfunction fromInt(value_0){\n  var rebase, result;\n  if (value_0 > -129 && value_0 < 128) {\n    rebase = value_0 + 128;\n    boxedValues == null && (boxedValues = initDim(_3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit, makeCastMap([Q$Serializable]), Q$LongLibBase$LongEmul, 256, 0));\n    result = boxedValues[rebase];\n    !result && (result = boxedValues[rebase] = create_0(value_0));\n    return result;\n  }\n  return create_0(value_0);\n}\n\nfunction gte_0(a, b){\n  var signa, signb;\n  signa = a.h >> 19;\n  signb = b.h >> 19;\n  return signa == 0?signb != 0 || a.h > b.h || a.h == b.h && a.m > b.m || a.h == b.h && a.m == b.m && a.l >= b.l:!(signb == 0 || a.h < b.h || a.h == b.h && a.m < b.m || a.h == b.h && a.m == b.m && a.l < b.l);\n}\n\nfunction neg(a){\n  var neg0, neg1, neg2;\n  neg0 = ~a.l + 1 & 4194303;\n  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;\n  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;\n  return create0(neg0, neg1, neg2);\n}\n\nfunction shl(a, n){\n  var res0, res1, res2;\n  n &= 63;\n  if (n < 22) {\n    res0 = a.l << n;\n    res1 = a.m << n | a.l >> 22 - n;\n    res2 = a.h << n | a.m >> 22 - n;\n  }\n   else if (n < 44) {\n    res0 = 0;\n    res1 = a.l << n - 22;\n    res2 = a.m << n - 22 | a.l >> 44 - n;\n  }\n   else {\n    res0 = 0;\n    res1 = 0;\n    res2 = a.l << n - 44;\n  }\n  return {l:res0 & 4194303, m:res1 & 4194303, h:res2 & 1048575};\n}\n\nfunction shr(a, n){\n  var a2, negative, res0, res1, res2;\n  n &= 63;\n  a2 = a.h;\n  negative = (a2 & 524288) != 0;\n  negative && (a2 |= -1048576);\n  if (n < 22) {\n    res2 = a2 >> n;\n    res1 = a.m >> n | a2 << 22 - n;\n    res0 = a.l >> n | a.m << 22 - n;\n  }\n   else if (n < 44) {\n    res2 = negative?1048575:0;\n    res1 = a2 >> n - 22;\n    res0 = a.m >> n - 22 | a2 << 44 - n;\n  }\n   else {\n    res2 = negative?1048575:0;\n    res1 = negative?4194303:0;\n    res0 = a2 >> n - 44;\n  }\n  return {l:res0 & 4194303, m:res1 & 4194303, h:res2 & 1048575};\n}\n\nfunction shru(a, n){\n  var a2, res0, res1, res2;\n  n &= 63;\n  a2 = a.h & 1048575;\n  if (n < 22) {\n    res2 = a2 >>> n;\n    res1 = a.m >> n | a2 << 22 - n;\n    res0 = a.l >> n | a.m << 22 - n;\n  }\n   else if (n < 44) {\n    res2 = 0;\n    res1 = a2 >>> n - 22;\n    res0 = a.m >> n - 22 | a.h << 44 - n;\n  }\n   else {\n    res2 = 0;\n    res1 = 0;\n    res0 = a2 >>> n - 44;\n  }\n  return {l:res0 & 4194303, m:res1 & 4194303, h:res2 & 1048575};\n}\n\nfunction sub_0(a, b){\n  var sum0, sum1, sum2;\n  sum0 = a.l - b.l;\n  sum1 = a.m - b.m + (sum0 >> 22);\n  sum2 = a.h - b.h + (sum1 >> 22);\n  return {l:sum0 & 4194303, m:sum1 & 4194303, h:sum2 & 1048575};\n}\n\nfunction toDouble(a){\n  if (eq(a, ($clinit_LongLib$Const() , MIN_VALUE))) {\n    return -9223372036854775808;\n  }\n  if (!gte_0(a, ZERO)) {\n    return -toDoubleHelper(neg(a));\n  }\n  return a.l + a.m * 4194304 + a.h * 17592186044416;\n}\n\nfunction toInt(a){\n  return a.l | a.m << 22;\n}\n\nfunction toString_6(a){\n  var digits, rem, res, tenPowerLong, zeroesNeeded;\n  if (a.l == 0 && a.m == 0 && a.h == 0) {\n    return '0';\n  }\n  if (a.h == 524288 && a.m == 0 && a.l == 0) {\n    return '-9223372036854775808';\n  }\n  if (a.h >> 19 != 0) {\n    return '-' + toString_6(neg(a));\n  }\n  rem = a;\n  res = '';\n  while (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {\n    tenPowerLong = fromInt(1000000000);\n    rem = divMod(rem, tenPowerLong, true);\n    digits = '' + toInt(remainder);\n    if (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {\n      zeroesNeeded = 9 - digits.length;\n      for (; zeroesNeeded > 0; zeroesNeeded--) {\n        digits = '0' + digits;\n      }\n    }\n    res = digits + res;\n  }\n  return res;\n}\n\nfunction xor(a, b){\n  return {l:a.l ^ b.l, m:a.m ^ b.m, h:a.h ^ b.h};\n}\n\nvar boxedValues;\nfunction $clinit_LongLib$Const(){\n  $clinit_LongLib$Const = nullMethod;\n  MAX_VALUE = create0(4194303, 4194303, 524287);\n  MIN_VALUE = create0(0, 0, 524288);\n  ONE = fromInt(1);\n  fromInt(2);\n  ZERO = fromInt(0);\n}\n\nvar MAX_VALUE, MIN_VALUE, ONE, ZERO;\nfunction isStatsAvailable(){\n  return !!$stats;\n}\n\nfunction onModuleStart(mainClassName){\n  return $stats({moduleName:$moduleName, sessionId:$sessionId, subSystem:'startup', evtGroup:'moduleStartup', millis:(new Date).getTime(), type:'onModuleLoadStart', className:mainClassName});\n}\n\nfunction $getLevel(this$static){\n  if (this$static.level) {\n    return this$static.level;\n  }\n  return $clinit_Level() , ALL;\n}\n\nfunction $setFormatter(this$static, newFormatter){\n  this$static.formatter = newFormatter;\n}\n\nfunction $setLevel(this$static, newLevel){\n  this$static.level = newLevel;\n}\n\ndefineSeed(137, 1, makeCastMap([Q$Handler]));\nfunction ConsoleLogHandler_0(){\n  $setFormatter(this, new TextLogFormatter_0(true));\n  $setLevel(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(136, 137, makeCastMap([Q$Handler]), ConsoleLogHandler_0);\n_.publish = function publish(record){\n  var msg, val;\n  if (!(window.console != null && window.console.firebug == null) || ($getLevel(this) , -2147483648) > record.level.intValue()) {\n    return;\n  }\n  msg = this.formatter.format(record);\n  val = record.level.intValue();\n  val >= ($clinit_Level() , 1000)?(window.console.error(msg) , undefined):val >= 900?(window.console.warn(msg) , undefined):val >= 800?(window.console.info(msg) , undefined):(window.console.log(msg) , undefined);\n}\n;\nfunction DevelopmentModeLogHandler_0(){\n  $setFormatter(this, new TextLogFormatter_0(false));\n  $setLevel(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(138, 137, makeCastMap([Q$Handler]), DevelopmentModeLogHandler_0);\n_.publish = function publish_0(record){\n  return;\n}\n;\nfunction $isSupported(){\n  return !!(window.console && window.console.firebug);\n}\n\nfunction $warn(message){\n  window.console.warn(message);\n}\n\nfunction FirebugLogHandler_0(){\n  $isSupported() && $warn('FirebugLogHandler is deprecated, use the ConsoleLogHandler instead.');\n  $setFormatter(this, new TextLogFormatter_0(true));\n  $setLevel(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(139, 137, makeCastMap([Q$Handler]), FirebugLogHandler_0);\n_.publish = function publish_1(record){\n  var msg, val;\n  if (!$isSupported() || ($getLevel(this) , -2147483648) > record.level.intValue()) {\n    return;\n  }\n  msg = this.formatter.format(record);\n  val = record.level.intValue();\n  val <= ($clinit_Level() , 500)?(window.console.debug(msg) , undefined):val < 900?(window.console.info(msg) , undefined):val < 1000?$warn(msg):(window.console.error(msg) , undefined);\n}\n;\n",
"function HasWidgetsLogHandler_0(){\n  $setFormatter(this, new HtmlLogFormatter_0);\n  $setLevel(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(140, 137, makeCastMap([Q$Handler]), HasWidgetsLogHandler_0);\n_.publish = function publish_2(record){\n  var formatter, msg;\n  if (($getLevel(this) , -2147483648) > record.level.intValue()) {\n    return;\n  }\n  formatter = this.formatter;\n  msg = formatter.format(record);\n  instanceOf(formatter, Q$HtmlLogFormatter)?(new HTML_0(msg) , undefined):(new Label_1(msg) , undefined);\n}\n;\ndefineSeed(143, 1, {});\nfunction $getRecordInfo(event_0, newline){\n  var date, s;\n  date = new Date_2(event_0.millis);\n  s = new StringBuilder_0;\n  $append_0(s, $toString_1(date));\n  $append(s.impl, ' ');\n  $append_0(s, event_0.loggerName);\n  $append(s.impl, newline);\n  $append_0(s, event_0.level.getName());\n  $append(s.impl, ': ');\n  return s.impl.string;\n}\n\ndefineSeed(142, 143, {});\nfunction $getColor(logLevel){\n  if (logLevel == ($clinit_Level() , 2147483647)) {\n    return '#000';\n  }\n  if (logLevel >= 1000) {\n    return '#F00';\n  }\n  if (logLevel >= 900) {\n    return '#E56717';\n  }\n  if (logLevel >= 800) {\n    return '#20b000';\n  }\n  if (logLevel >= 700) {\n    return '#2B60DE';\n  }\n  if (logLevel >= 500) {\n    return '#F0F';\n  }\n  if (logLevel >= 400) {\n    return '#F0F';\n  }\n  if (logLevel >= 300) {\n    return '#F0F';\n  }\n  return '#000';\n}\n\nfunction $getEscaped(text_0){\n  text_0 = $replaceAll(text_0, '<', '&lt;');\n  text_0 = $replaceAll(text_0, '>', '&gt;');\n  text_0 = $replaceAll(text_0, '\\t', '&nbsp;&nbsp;&nbsp;');\n  return text_0;\n}\n\nfunction HtmlLogFormatter_0(){\n  this.showStackTraces = true;\n}\n\ndefineSeed(141, 142, makeCastMap([Q$HtmlLogFormatter]), HtmlLogFormatter_0);\n_.format = function format(event_0){\n  var html, prefix;\n  html = new StringBuilder_0;\n  $append_0(html, (prefix = new StringBuilder_0 , $append(prefix.impl, \"<span style='color:\") , $append_0(prefix, $getColor(event_0.level.intValue())) , $append(prefix.impl, \"'>\") , $append(prefix.impl, '<code>') , prefix.impl.string));\n  $append_0(html, $getRecordInfo(event_0, ' '));\n  $append_0(html, $getEscaped(event_0.msg));\n  this.showStackTraces && !!event_0.thrown && $printStackTrace(event_0.thrown, new HtmlLogFormatter$1_0(html, html));\n  $append(html.impl, '<\\/code><\\/span>');\n  return html.impl.string;\n}\n;\n_.showStackTraces = false;\ndefineSeed(148, 1, {});\ndefineSeed(147, 148, {});\nfunction PrintStream_0(){\n}\n\ndefineSeed(146, 147, {}, PrintStream_0);\n_.println = function println(s){\n}\n;\nfunction StackTracePrintStream_0(builder){\n  this.builder = builder;\n}\n\ndefineSeed(145, 146, {}, StackTracePrintStream_0);\n_.append = function append(text_0){\n  $append_0(this.builder, text_0);\n}\n;\n_.newLine = function newLine(){\n  $append_0(this.builder, '\\n');\n}\n;\n_.println = function println_0(str){\n  this.append(str);\n  this.newLine();\n}\n;\nfunction HtmlLogFormatter$1_0($anonymous0, val$html){\n  this.val$html = val$html;\n  StackTracePrintStream_0.call(this, $anonymous0);\n}\n\ndefineSeed(144, 145, {}, HtmlLogFormatter$1_0);\n_.append = function append_0(str){\n  $append_0(this.val$html, $getEscaped(str));\n}\n;\n_.newLine = function newLine_0(){\n  $append_0(this.val$html, '<br>');\n}\n;\nfunction $clinit_LogConfiguration(){\n  $clinit_LogConfiguration = nullMethod;\n  impl = new LogConfiguration$LogConfigurationImplRegular_0;\n}\n\nfunction $onModuleLoad(){\n  var log_0;\n  $configureClientSideLogging(impl);\n  if (!uncaughtExceptionHandler) {\n    log_0 = ($clinit_Logger() , $getLoggerHelper(Lcom_google_gwt_logging_client_LogConfiguration_2_classLit.typeName));\n    setUncaughtExceptionHandler(new LogConfiguration$1_0(log_0));\n  }\n}\n\nvar impl;\nfunction LogConfiguration$1_0(val$log){\n  this.val$log = val$log;\n}\n\ndefineSeed(150, 1, {}, LogConfiguration$1_0);\nfunction $addHandlerIfNotNull(l_0, h_0){\n  $addHandler(l_0.impl, h_0);\n}\n\nfunction $configureClientSideLogging(this$static){\n  this$static.root = ($clinit_Logger() , $getLoggerHelper(''));\n  this$static.root.impl.useParentHandlers = false;\n  $setLevels(this$static.root);\n  $setDefaultHandlers(this$static.root);\n}\n\nfunction $parseLevel(s){\n  if (s == null) {\n    return null;\n  }\n  if ($equals(s, ($clinit_Level() , 'OFF'))) {\n    return OFF;\n  }\n   else if ($equals(s, 'SEVERE')) {\n    return SEVERE;\n  }\n   else if ($equals(s, 'WARNING')) {\n    return WARNING;\n  }\n   else if ($equals(s, 'INFO')) {\n    return INFO;\n  }\n   else if ($equals(s, 'CONFIG')) {\n    return CONFIG;\n  }\n   else if ($equals(s, 'FINE')) {\n    return FINE;\n  }\n   else if ($equals(s, 'FINER')) {\n    return FINER;\n  }\n   else if ($equals(s, 'FINEST')) {\n    return FINEST;\n  }\n   else if ($equals(s, 'ALL')) {\n    return ALL;\n  }\n  return null;\n}\n\nfunction $setDefaultHandlers(l_0){\n  var console_0, dev, firebug, loggingWidget, remote, system;\n  console_0 = new ConsoleLogHandler_0;\n  $addHandler(l_0.impl, console_0);\n  dev = new DevelopmentModeLogHandler_0;\n  $addHandler(l_0.impl, dev);\n  firebug = new FirebugLogHandler_0;\n  $addHandler(l_0.impl, firebug);\n  system = new SystemLogHandler_0;\n  $addHandler(l_0.impl, system);\n  remote = new NullLogHandler_0;\n  !!remote || $addHandler(l_0.impl, null);\n  loggingWidget = new NullLoggingPopup_0;\n  !loggingWidget && $addHandlerIfNotNull(l_0, new HasWidgetsLogHandler_0);\n}\n\nfunction $setLevels(l_0){\n  var paramLevel, paramsForName;\n  paramLevel = $parseLevel((ensureListParameterMap() , paramsForName = dynamicCast(listParamMap.get_0('logLevel'), Q$List) , !paramsForName?null:dynamicCast(paramsForName.get_1(paramsForName.size_1() - 1), Q$String)));\n  paramLevel?$setLevel_0(l_0.impl, paramLevel):$setLevel_1(l_0, ($clinit_Level() , INFO));\n}\n\nfunction LogConfiguration$LogConfigurationImplRegular_0(){\n}\n\ndefineSeed(151, 1, {}, LogConfiguration$LogConfigurationImplRegular_0);\nfunction NullLogHandler_0(){\n}\n\ndefineSeed(152, 137, makeCastMap([Q$Handler]), NullLogHandler_0);\n_.publish = function publish_3(record){\n}\n;\nfunction NullLoggingPopup_0(){\n}\n\ndefineSeed(153, 1, {}, NullLoggingPopup_0);\n_.iterator = function iterator(){\n  return null;\n}\n;\nfunction SystemLogHandler_0(){\n  $setFormatter(this, new TextLogFormatter_0(true));\n  $setLevel(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(154, 137, makeCastMap([Q$Handler]), SystemLogHandler_0);\n_.publish = function publish_4(record){\n  return;\n}\n;\nfunction TextLogFormatter_0(showStackTraces){\n  this.showStackTraces = showStackTraces;\n}\n\ndefineSeed(155, 142, {}, TextLogFormatter_0);\n_.format = function format_0(event_0){\n  var message;\n  message = new StringBuilder_0;\n  $append_0(message, $getRecordInfo(event_0, '\\n'));\n  $append_0(message, event_0.msg);\n  this.showStackTraces && !!event_0.thrown && $printStackTrace(event_0.thrown, new StackTracePrintStream_0(message));\n  return message.impl.string;\n}\n;\n_.showStackTraces = false;\nfunction $addHandler(this$static, handler){\n  $add_1(this$static.handlers, handler);\n}\n\nfunction $getEffectiveLevel(this$static){\n  var effectiveLevel, logger;\n  if (this$static.level) {\n    return this$static.level;\n  }\n  logger = this$static.parent_0;\n  while (logger) {\n    effectiveLevel = logger.impl.level;\n    if (effectiveLevel) {\n      return effectiveLevel;\n    }\n    logger = logger.impl.parent_0;\n  }\n  return $clinit_Level() , INFO;\n}\n\nfunction $getHandlers(this$static){\n  return dynamicCast($toArray(this$static.handlers, initDim(_3Ljava_util_logging_Handler_2_classLit, makeCastMap([Q$Serializable, Q$Handler_$1]), Q$Handler, this$static.handlers.size_0, 0)), Q$Handler_$1);\n}\n\nfunction $getLoggerHelper(name_0){\n  var logger, manager, newLogger;\n  manager = (!singleton && (singleton = new LogManager_0) , singleton);\n  logger = dynamicCast($get(manager.loggerList, name_0), Q$Logger);\n  if (!logger) {\n    newLogger = new LoggerWithExposedConstructor_0(name_0);\n    $addLogger(manager, newLogger);\n    return newLogger;\n  }\n  return logger;\n}\n\nfunction $isLoggable(this$static, messageLevel){\n  return $getEffectiveLevel(this$static).intValue() <= messageLevel.intValue();\n}\n\nfunction $log(this$static, level, msg, thrown){\n  var record;\n  if ($getEffectiveLevel(this$static).intValue() <= level.intValue()) {\n    record = new LogRecord_0(level, msg);\n    record.thrown = instanceOf(thrown, Q$SerializableThrowable)?dynamicCast(thrown, Q$SerializableThrowable):thrown?createSerializable(thrown):null;\n    $setLoggerName(record, this$static.name_0);\n    $log_0(this$static, record);\n  }\n}\n\nfunction $log_0(this$static, record){\n  var handler, handler$array, handler$array0, handler$index, handler$index0, handler$max, handler$max0, logger;\n  if ($isLoggable(this$static, record.level)) {\n    for (handler$array = dynamicCast($toArray(this$static.handlers, initDim(_3Ljava_util_logging_Handler_2_classLit, makeCastMap([Q$Serializable, Q$Handler_$1]), Q$Handler, this$static.handlers.size_0, 0)), Q$Handler_$1) , handler$index = 0 , handler$max = handler$array.length; handler$index < handler$max; ++handler$index) {\n      handler = handler$array[handler$index];\n      handler.publish(record);\n    }\n    logger = this$static.useParentHandlers?this$static.parent_0:null;\n    while (logger) {\n      for (handler$array0 = $getHandlers(logger.impl) , handler$index0 = 0 , handler$max0 = handler$array0.length; handler$index0 < handler$max0; ++handler$index0) {\n        handler = handler$array0[handler$index0];\n        handler.publish(record);\n      }\n      logger = logger.impl.useParentHandlers?logger.impl.parent_0:null;\n    }\n  }\n}\n\nfunction $setLevel_0(this$static, newLevel){\n  this$static.level = newLevel;\n}\n\nfunction $setName(this$static, newName){\n  this$static.name_0 = newName;\n}\n\nfunction $setParent(this$static, newParent){\n  !!newParent && (this$static.parent_0 = newParent);\n}\n\nfunction LoggerImplRegular_0(){\n  this.useParentHandlers = true;\n  this.handlers = new ArrayList_0;\n}\n\ndefineSeed(156, 1, {}, LoggerImplRegular_0);\n_.level = null;\n_.useParentHandlers = false;\nfunction $clinit_Logger(){\n  $clinit_Logger = nullMethod;\n  new LoggerImplRegular_0;\n}\n\nfunction $log_1(this$static, level, msg){\n  $log(this$static.impl, level, msg, null);\n}\n\nfunction $log_2(this$static, level, msg, thrown){\n  $log(this$static.impl, level, msg, thrown);\n}\n\nfunction $setLevel_1(this$static, newLevel){\n  $setLevel_0(this$static.impl, newLevel);\n}\n\nfunction Logger_0(name_0){\n  $clinit_Logger();\n  this.impl = new LoggerImplRegular_0;\n  $setName(this.impl, name_0);\n}\n\ndefineSeed(158, 1, makeCastMap([Q$Logger]), Logger_0);\nfunction LoggerWithExposedConstructor_0(name_0){\n  $clinit_Logger();\n  Logger_0.call(this, name_0);\n}\n\ndefineSeed(157, 158, makeCastMap([Q$Logger]), LoggerWithExposedConstructor_0);\nfunction $set_0(this$static, array, offset){\n  this$static.set(array, offset);\n}\n\nfunction $clinit_DOM(){\n  $clinit_DOM = nullMethod;\n  $clinit_DOMImplMozilla();\n}\n\nvar currentEvent = null, sCaptureElem;\nfunction $onModuleLoad_0(){\n  var allowedModes, currentMode, i;\n  currentMode = $doc.compatMode;\n  allowedModes = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable]), Q$String, ['CSS1Compat']);\n  for (i = 0; i < allowedModes.length; i++) {\n    if ($equals(allowedModes[i], currentMode)) {\n      return;\n    }\n  }\n  allowedModes.length == 1 && $equals('CSS1Compat', allowedModes[0]) && $equals('BackCompat', currentMode)?\"GWT no longer supports Quirks Mode (document.compatMode=' BackCompat').<br>Make sure your application's host HTML page has a Standards Mode (document.compatMode=' CSS1Compat') doctype,<br>e.g. by using &lt;!doctype html&gt; at the start of your application's HTML page.<br><br>To continue using this unsupported rendering mode and risk layout problems, suppress this message by adding<br>the following line to your*.gwt.xml module file:<br>&nbsp;&nbsp;&lt;extend-configuration-property name=\\\"document.compatMode\\\" value=\\\"\" + currentMode + '\"/&gt;':\"Your *.gwt.xml module configuration prohibits the use of the current doucment rendering mode (document.compatMode=' \" + currentMode + \"').<br>Modify your application's host HTML page doctype, or update your custom 'document.compatMode' configuration property settings.\";\n}\n\nfunction buildListParamMap(queryString){\n  var entry, entry$iterator, kv, kvPair, kvPair$array, kvPair$index, kvPair$max, out, qs, values, regexp;\n  out = new HashMap_0;\n  if (queryString != null && queryString.length > 1) {\n    qs = $substring(queryString, 1);\n    for (kvPair$array = $split(qs, '&', 0) , kvPair$index = 0 , kvPair$max = kvPair$array.length; kvPair$index < kvPair$max; ++kvPair$index) {\n      kvPair = kvPair$array[kvPair$index];\n      kv = $split(kvPair, '=', 2);\n      if (kv[0].length == 0) {\n        continue;\n      }\n      values = dynamicCast(out.get_0(kv[0]), Q$List);\n      if (!values) {\n        values = new ArrayList_0;\n        out.put(kv[0], values);\n      }\n      values.add_0(kv.length > 1?(throwIfNull(kv[1]) , regexp = /\\+/g , decodeURIComponent(kv[1].replace(regexp, '%20'))):'');\n    }\n  }\n  for (entry$iterator = out.entrySet_0().iterator(); entry$iterator.hasNext();) {\n    entry = dynamicCast(entry$iterator.next(), Q$Map$Entry);\n    entry.setValue(unmodifiableList(dynamicCast(entry.getValue(), Q$List)));\n  }\n  out = new Collections$UnmodifiableMap_0(out);\n  return out;\n}\n\nfunction ensureListParameterMap(){\n  var currentQueryString;\n  currentQueryString = $wnd.location.search;\n  if (!listParamMap || !$equals(cachedQueryString, currentQueryString)) {\n    listParamMap = buildListParamMap(currentQueryString);\n    cachedQueryString = currentQueryString;\n  }\n}\n\nvar cachedQueryString = '', listParamMap;\nfunction $eventGetTypeInt(eventType){\n  switch (eventType) {\n    case 'blur':\n      return 4096;\n    case 'change':\n      return 1024;\n    case 'click':\n      return 1;\n    case 'dblclick':\n      return 2;\n    case 'focus':\n      return 2048;\n    case 'keydown':\n      return 128;\n    case 'keypress':\n      return 256;\n    case 'keyup':\n      return 512;\n    case 'load':\n      return 32768;\n    case 'losecapture':\n      return 8192;\n    case 'mousedown':\n      return 4;\n    case 'mousemove':\n      return 64;\n    case 'mouseout':\n      return 32;\n    case 'mouseover':\n      return 16;\n    case 'mouseup':\n      return 8;\n    case 'scroll':\n      return 16384;\n    case 'error':\n      return 65536;\n    case 'DOMMouseScroll':\n    case 'mousewheel':\n      return 131072;\n    case 'contextmenu':\n      return 262144;\n    case 'paste':\n      return 524288;\n    case 'touchstart':\n      return 1048576;\n    case 'touchmove':\n      return 2097152;\n    case 'touchend':\n      return 4194304;\n    case 'touchcancel':\n      return 8388608;\n    case 'gesturestart':\n      return 16777216;\n    case 'gesturechange':\n      return 33554432;\n    case 'gestureend':\n      return 67108864;\n    default:return -1;\n  }\n}\n\nfunction $clinit_DOMImplStandard(){\n  $clinit_DOMImplStandard = nullMethod;\n  captureEventDispatchers = {click:dispatchCapturedMouseEvent, dblclick:dispatchCapturedMouseEvent, mousedown:dispatchCapturedMouseEvent, mouseup:dispatchCapturedMouseEvent, mousemove:dispatchCapturedMouseEvent, mouseover:dispatchCapturedMouseEvent, mouseout:dispatchCapturedMouseEvent, mousewheel:dispatchCapturedMouseEvent, keydown:dispatchCapturedEvent, keyup:dispatchCapturedEvent, keypress:dispatchCapturedEvent, touchstart:dispatchCapturedMouseEvent, touchend:dispatchCapturedMouseEvent, touchmove:dispatchCapturedMouseEvent, touchcancel:dispatchCapturedMouseEvent, gesturestart:dispatchCapturedMouseEvent, gestureend:dispatchCapturedMouseEvent, gesturechange:dispatchCapturedMouseEvent};\n}\n\nfunction dispatchCapturedEvent(evt){\n  $clinit_DOM();\n}\n\nfunction dispatchCapturedMouseEvent(evt){\n  $clinit_DOMImplStandard();\n  $clinit_DOM();\n  return;\n}\n\nvar captureEventDispatchers;\nfunction $clinit_DOMImplMozilla(){\n  $clinit_DOMImplMozilla = nullMethod;\n  $clinit_DOMImplStandard();\n  captureEventDispatchers['DOMMouseScroll'] = dispatchCapturedMouseEvent;\n}\n\nfunction $setTextOrHtml(this$static, content_0, isHtml){\n  isHtml?$setInnerHTML(this$static.element, content_0):$setInnerText(this$static.element, content_0);\n  if (this$static.textDir != this$static.initialElementDir) {\n    this$static.textDir = this$static.initialElementDir;\n    setDirectionOnElement(this$static.element, this$static.initialElementDir);\n  }\n}\n\nfunction DirectionalTextHelper_0(element){\n  this.element = element;\n  this.initialElementDir = getDirectionOnElement(element);\n  this.textDir = this.initialElementDir;\n}\n\ndefineSeed(170, 1, {}, DirectionalTextHelper_0);\nfunction $setElement(this$static, elem){\n  this$static.element = elem;\n}\n\ndefineSeed(175, 1, {});\n_.toString$ = function toString_7(){\n  if (!this.element) {\n    return '(null handle)';\n  }\n  return $toString(($clinit_DOM() , this.element));\n}\n;\ndefineSeed(174, 175, makeCastMap([Q$EventListener]));\n_.onBrowserEvent = function onBrowserEvent(event_0){\n  var related;\n  switch ($clinit_DOM() , $eventGetTypeInt(event_0.type)) {\n    case 16:\n    case 32:\n      related = $eventGetRelatedTarget(event_0);\n      if (!!related && $isOrHasChild(this.element, related)) {\n        return;\n      }\n\n  }\n  fireNativeEvent($clinit_DOM());\n}\n;\nfunction LabelBase_0(element){\n  $setElement(this, ($clinit_DOM() , element));\n  this.directionalTextHelper = new DirectionalTextHelper_0(this.element);\n}\n\ndefineSeed(173, 174, makeCastMap([Q$EventListener]));\nfunction Label_0(element){\n  LabelBase_0.call(this, element, $equalsIgnoreCase('span', element.tagName));\n}\n\nfunction Label_1(text_0){\n  LabelBase_0.call(this, $doc.createElement('div'));\n  $setClassName(($clinit_DOM() , this.element), 'gwt-Label');\n  $setTextOrHtml(this.directionalTextHelper, text_0, false);\n}\n\ndefineSeed(172, 173, makeCastMap([Q$EventListener]), Label_1);\nfunction HTML_0(html){\n  Label_0.call(this, $doc.createElement('div'));\n  $setClassName(($clinit_DOM() , this.element), 'gwt-HTML');\n  $setTextOrHtml(this.directionalTextHelper, html, true);\n}\n\ndefineSeed(171, 172, makeCastMap([Q$EventListener]), HTML_0);\nfunction $clinit_HasHorizontalAlignment(){\n  $clinit_HasHorizontalAlignment = nullMethod;\n  $clinit_Style$TextAlign();\n}\n\nfunction $getRuntimeValue(){\n  var ua = navigator.userAgent.toLowerCase();\n  var makeVersion = function(result){\n    return parseInt(result[1]) * 1000 + parseInt(result[2]);\n  }\n  ;\n  if (function(){\n    return ua.indexOf('webkit') != -1;\n  }\n  ())\n    return 'safari';\n  if (function(){\n    return ua.indexOf('msie') != -1 && $doc.documentMode >= 10;\n  }\n  ())\n    return 'ie10';\n  if (function(){\n    return ua.indexOf('msie') != -1 && $doc.documentMode >= 9;\n  }\n  ())\n    return 'ie9';\n  if (function(){\n    return ua.indexOf('msie') != -1 && $doc.documentMode >= 8;\n  }\n  ())\n    return 'ie8';\n  if (function(){\n    return ua.indexOf('gecko') != -1;\n  }\n  ())\n    return 'gecko1_8';\n  return 'unknown';\n}\n\nfunction ArithmeticException_0(){\n  RuntimeException_1.call(this, 'divide by zero');\n}\n\ndefineSeed(178, 86, makeCastMap([Q$Serializable, Q$Throwable]), ArithmeticException_0);\nfunction ArrayStoreException_0(){\n  RuntimeException_0.call(this);\n}\n\nfunction ArrayStoreException_1(message){\n  RuntimeException_1.call(this, message);\n}\n\ndefineSeed(179, 86, makeCastMap([Q$Serializable, Q$Throwable]), ArrayStoreException_0, ArrayStoreException_1);\nfunction $clinit_Boolean(){\n  $clinit_Boolean = nullMethod;\n  new Boolean_1(false);\n  TRUE = new Boolean_1(true);\n}\n\nfunction Boolean_1(value_0){\n  this.value_0 = value_0;\n}\n\ndefineSeed(180, 1, makeCastMap([Q$Serializable, Q$Boolean, Q$Comparable]), Boolean_1);\n_.equals$ = function equals_1(o){\n  return instanceOf(o, Q$Boolean) && dynamicCast(o, Q$Boolean).value_0 == this.value_0;\n}\n;\n_.hashCode$ = function hashCode_2(){\n  return this.value_0?1231:1237;\n}\n;\n_.toString$ = function toString_8(){\n  return this.value_0?'true':'false';\n}\n;\n_.value_0 = false;\nvar TRUE;\nfunction Class_0(){\n}\n\nfunction createForArray(packageName, className, seedId, componentType){\n  var clazz;\n  clazz = new Class_0;\n  setName(clazz, packageName, className, seedId != 0?-seedId:0);\n  clazz.modifiers = 4;\n  clazz.componentType = componentType;\n  return clazz;\n}\n\nfunction createForClass(packageName, className, seedId){\n  var clazz;\n  clazz = new Class_0;\n  setName(clazz, packageName, className, seedId);\n  return clazz;\n}\n\nfunction createForEnum(packageName, className, seedId, enumConstantsFunc){\n  var clazz;\n  clazz = new Class_0;\n  setName(clazz, packageName, className, seedId);\n  clazz.modifiers = enumConstantsFunc?8:0;\n  return clazz;\n}\n\nfunction createForPrimitive(className, seedId){\n  var clazz;\n  clazz = new Class_0;\n  setName(clazz, '', className, seedId);\n  clazz.modifiers = 1;\n  return clazz;\n}\n\nfunction getSeedFunction(clazz){\n  var func = seedTable[clazz.seedId];\n  clazz = null;\n  return func;\n}\n\nfunction setClassLiteral(seedId, clazz){\n  var proto;\n  clazz.seedId = seedId;\n  if (seedId == 2) {\n    proto = String.prototype;\n  }\n   else {\n    if (seedId > 0) {\n      var seed = getSeedFunction(clazz);\n      if (seed) {\n        proto = seed.prototype;\n      }\n       else {\n        seed = seedTable[seedId] = function(){\n        }\n        ;\n        seed.___clazz$ = clazz;\n        return;\n      }\n    }\n     else {\n      return;\n    }\n  }\n  proto.___clazz$ = clazz;\n}\n\nfunction setName(clazz, packageName, className, seedId){\n  clazz.typeName = packageName + className;\n  clazz.simpleName = className;\n  typeof seedId == 'number' && seedId > 0 && setClassLiteral(seedId, clazz);\n}\n\ndefineSeed(181, 1, {}, Class_0);\n_.toString$ = function toString_9(){\n  return ((this.modifiers & 2) != 0?'interface ':(this.modifiers & 1) != 0?'':'class ') + this.typeName;\n}\n;\n_.modifiers = 0;\n_.seedId = 0;\nfunction ClassCastException_0(){\n  RuntimeException_0.call(this);\n}\n\ndefineSeed(182, 86, makeCastMap([Q$Serializable, Q$Throwable]), ClassCastException_0);\ndefineSeed(184, 1, makeCastMap([Q$Serializable, Q$Number]));\nfunction Float_0(value_0){\n  this.value_0 = value_0;\n}\n\ndefineSeed(185, 184, makeCastMap([Q$Serializable, Q$Comparable, Q$Float, Q$Number]), Float_0);\n_.equals$ = function equals_2(o){\n  return instanceOf(o, Q$Float) && dynamicCast(o, Q$Float).value_0 == this.value_0;\n}\n;\n_.hashCode$ = function hashCode_3(){\n  return round_int(this.value_0);\n}\n;\n_.toString$ = function toString_10(){\n  return '' + this.value_0;\n}\n;\n_.value_0 = 0;\nfunction IllegalArgumentException_0(message){\n  RuntimeException_1.call(this, message);\n}\n\ndefineSeed(186, 86, makeCastMap([Q$Serializable, Q$Throwable]), IllegalArgumentException_0);\nfunction IllegalStateException_0(){\n  RuntimeException_0.call(this);\n}\n\nfunction IllegalStateException_1(s){\n  RuntimeException_1.call(this, s);\n}\n\ndefineSeed(187, 86, makeCastMap([Q$Serializable, Q$Throwable]), IllegalStateException_0, IllegalStateException_1);\nfunction IndexOutOfBoundsException_0(){\n  RuntimeException_0.call(this);\n}\n\nfunction IndexOutOfBoundsException_1(message){\n  RuntimeException_1.call(this, message);\n}\n\ndefineSeed(188, 86, makeCastMap([Q$Serializable, Q$Throwable]), IndexOutOfBoundsException_0, IndexOutOfBoundsException_1);\nfunction Integer_0(value_0){\n  this.value_0 = value_0;\n}\n\nfunction numberOfLeadingZeros_0(i){\n  var m_0, n, y_0;\n  if (i < 0) {\n    return 0;\n  }\n   else if (i == 0) {\n    return 32;\n  }\n   else {\n    y_0 = -(i >> 16);\n    m_0 = y_0 >> 16 & 16;\n    n = 16 - m_0;\n    i = i >> m_0;\n    y_0 = i - 256;\n    m_0 = y_0 >> 16 & 8;\n    n += m_0;\n    i <<= m_0;\n    y_0 = i - 4096;\n    m_0 = y_0 >> 16 & 4;\n    n += m_0;\n    i <<= m_0;\n    y_0 = i - 16384;\n    m_0 = y_0 >> 16 & 2;\n    n += m_0;\n    i <<= m_0;\n    y_0 = i >> 14;\n    m_0 = y_0 & ~(y_0 >> 1);\n    return n + 2 - m_0;\n  }\n}\n\nfunction numberOfTrailingZeros(i){\n  var r, rtn;\n  if (i == 0) {\n    return 32;\n  }\n   else {\n    rtn = 0;\n    for (r = 1; (r & i) == 0; r <<= 1) {\n      ++rtn;\n    }\n    return rtn;\n  }\n}\n\nfunction toPowerOfTwoString(value_0){\n  var buf, digits, pos;\n  buf = initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);\n  digits = ($clinit_Number$__Digits() , digits_0);\n  pos = 7;\n  if (value_0 >= 0) {\n    while (value_0 > 15) {\n      buf[pos--] = digits[value_0 & 15];\n      value_0 >>= 4;\n    }\n  }\n   else {\n    while (pos > 0) {\n      buf[pos--] = digits[value_0 & 15];\n      value_0 >>= 4;\n    }\n  }\n  buf[pos] = digits[value_0 & 15];\n  return __valueOf(buf, pos, 8);\n}\n\nfunction valueOf(i){\n  var rebase, result;\n  if (i > -129 && i < 128) {\n    rebase = i + 128;\n    result = ($clinit_Integer$BoxedValues() , boxedValues_0)[rebase];\n    !result && (result = boxedValues_0[rebase] = new Integer_0(i));\n    return result;\n  }\n  return new Integer_0(i);\n}\n\ndefineSeed(189, 184, makeCastMap([Q$Serializable, Q$Comparable, Q$Integer, Q$Number]), Integer_0);\n_.equals$ = function equals_3(o){\n  return instanceOf(o, Q$Integer) && dynamicCast(o, Q$Integer).value_0 == this.value_0;\n}\n;\n_.hashCode$ = function hashCode_4(){\n  return this.value_0;\n}\n;\n_.toString$ = function toString_11(){\n  return '' + this.value_0;\n}\n;\n_.value_0 = 0;\nfunction $clinit_Integer$BoxedValues(){\n  $clinit_Integer$BoxedValues = nullMethod;\n  boxedValues_0 = initDim(_3Ljava_lang_Integer_2_classLit, makeCastMap([Q$Serializable]), Q$Integer, 256, 0);\n}\n\nvar boxedValues_0;\nfunction abs_0(x_0){\n  return x_0 <= 0?0 - x_0:x_0;\n}\n\nfunction cos_0(x_0){\n  return Math.cos(x_0);\n}\n\nfunction log_1(x_0){\n  return Math.log(x_0);\n}\n\nfunction max_0(x_0, y_0){\n  return x_0 > y_0?x_0:y_0;\n}\n\nfunction max_1(x_0, y_0){\n  return x_0 > y_0?x_0:y_0;\n}\n\nfunction min_0(x_0, y_0){\n  return x_0 < y_0?x_0:y_0;\n}\n\nfunction random(){\n  return Math.random();\n}\n\nfunction sqrt_0(x_0){\n  return Math.sqrt(x_0);\n}\n\nfunction NullPointerException_0(){\n  RuntimeException_0.call(this);\n}\n\nfunction NullPointerException_1(message){\n  RuntimeException_1.call(this, message);\n}\n\ndefineSeed(192, 86, makeCastMap([Q$Serializable, Q$Throwable]), NullPointerException_0, NullPointerException_1);\nfunction $clinit_Number$__Digits(){\n  $clinit_Number$__Digits = nullMethod;\n  digits_0 = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]);\n}\n\nvar digits_0;\nfunction StackTraceElement_0(methodName){\n  this.className_0 = 'Unknown';\n  this.methodName = methodName;\n  this.lineNumber = -1;\n}\n\ndefineSeed(194, 1, makeCastMap([Q$Serializable, Q$StackTraceElement]), StackTraceElement_0);\n_.toString$ = function toString_12(){\n  return this.className_0 + '.' + this.methodName + '(Unknown Source' + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';\n}\n;\n_.lineNumber = 0;\nfunction $charAt(this$static, index_0){\n  return this$static.charCodeAt(index_0);\n}\n\nfunction $equals(this$static, other){\n  if (!instanceOf(other, Q$String)) {\n    return false;\n  }\n  return String(this$static) == other;\n}\n\nfunction $equalsIgnoreCase(this$static, other){\n  if (other == null)\n    return false;\n  return this$static == other || this$static.toLowerCase() == other.toLowerCase();\n}\n\nfunction $indexOf(this$static, str){\n  return this$static.indexOf(str);\n}\n\nfunction $lastIndexOf(this$static, str){\n  return this$static.lastIndexOf(str);\n}\n\nfunction $replaceAll(this$static, regex, replace){\n  replace = __translateReplaceString(replace);\n  return this$static.replace(RegExp(regex, 'g'), replace);\n}\n\nfunction $split(this$static, regex, maxMatch){\n  var compiled = new RegExp(regex, 'g');\n  var out = [];\n  var count = 0;\n  var trail = this$static;\n  var lastTrail = null;\n  while (true) {\n    var matchObj = compiled.exec(trail);\n    if (matchObj == null || trail == '' || count == maxMatch - 1 && maxMatch > 0) {\n      out[count] = trail;\n      break;\n    }\n     else {\n      out[count] = trail.substring(0, matchObj.index);\n      trail = trail.substring(matchObj.index + matchObj[0].length, trail.length);\n      compiled.lastIndex = 0;\n      if (lastTrail == trail) {\n        out[count] = trail.substring(0, 1);\n        trail = trail.substring(1);\n      }\n      lastTrail = trail;\n      count++;\n    }\n  }\n  if (maxMatch == 0 && this$static.length > 0) {\n    var lastNonEmpty = out.length;\n    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {\n      --lastNonEmpty;\n    }\n    lastNonEmpty < out.length && out.splice(lastNonEmpty, out.length - lastNonEmpty);\n  }\n  var jr = __createArray(out.length);\n  for (var i = 0; i < out.length; ++i) {\n    jr[i] = out[i];\n  }\n  return jr;\n}\n\nfunction $substring(this$static, beginIndex){\n  return this$static.substr(beginIndex, this$static.length - beginIndex);\n}\n\nfunction $substring_0(this$static, beginIndex, endIndex){\n  return this$static.substr(beginIndex, endIndex - beginIndex);\n}\n\nfunction $trim(this$static){\n  if (this$static.length == 0 || this$static[0] > ' ' && this$static[this$static.length - 1] > ' ') {\n    return this$static;\n  }\n  var r1 = this$static.replace(/^(\\s*)/, '');\n  var r2 = r1.replace(/\\s*$/, '');\n  return r2;\n}\n\nfunction __createArray(numElements){\n  return initDim(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable]), Q$String, numElements, 0);\n}\n\nfunction __translateReplaceString(replaceStr){\n  var pos;\n  pos = 0;\n  while (0 <= (pos = replaceStr.indexOf('\\\\', pos))) {\n    replaceStr.charCodeAt(pos + 1) == 36?(replaceStr = $substring_0(replaceStr, 0, pos) + '$' + $substring(replaceStr, ++pos)):(replaceStr = $substring_0(replaceStr, 0, pos) + $substring(replaceStr, ++pos));\n  }\n  return replaceStr;\n}\n\nfunction __valueOf(x_0, start_0, end){\n  x_0 = x_0.slice(start_0, end);\n  return String.fromCharCode.apply(null, x_0);\n}\n\nfunction fromCharCode(ch_0){\n  return String.fromCharCode(ch_0);\n}\n\nfunction fromCodePoint(codePoint){\n  var hiSurrogate, loSurrogate;\n  if (codePoint >= 65536) {\n    hiSurrogate = 55296 + (codePoint - 65536 >> 10 & 1023) & 65535;\n    loSurrogate = 56320 + (codePoint - 65536 & 1023) & 65535;\n    return fromCharCode(hiSurrogate) + fromCharCode(loSurrogate);\n  }\n   else {\n    return String.fromCharCode(codePoint & 65535);\n  }\n}\n\n_ = String.prototype;\n",
"_.castableTypeMap$ = makeCastMap([Q$String, Q$Serializable, Q$CharSequence, Q$Comparable]);\n_.equals$ = function equals_4(other){\n  return $equals(this, other);\n}\n;\n_.hashCode$ = function hashCode_5(){\n  return getHashCode_0(this);\n}\n;\n_.toString$ = _.toString;\nfunction $clinit_String$HashCache(){\n  $clinit_String$HashCache = nullMethod;\n  back_0 = {};\n  front = {};\n}\n\nfunction compute(str){\n  var hashCode, i, n, nBatch;\n  hashCode = 0;\n  n = str.length;\n  nBatch = n - 4;\n  i = 0;\n  while (i < nBatch) {\n    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode))) | 0;\n    i += 4;\n  }\n  while (i < n) {\n    hashCode = hashCode * 31 + $charAt(str, i++);\n  }\n  return hashCode | 0;\n}\n\nfunction getHashCode_0(str){\n  $clinit_String$HashCache();\n  var key = ':' + str;\n  var result = front[key];\n  if (result != null) {\n    return result;\n  }\n  result = back_0[key];\n  result == null && (result = compute(str));\n  increment();\n  return front[key] = result;\n}\n\nfunction increment(){\n  if (count_0 == 256) {\n    back_0 = front;\n    front = {};\n    count_0 = 0;\n  }\n  ++count_0;\n}\n\nvar back_0, count_0 = 0, front;\nfunction StringBuffer_0(){\n  this.impl = new StringBufferImplAppend_0;\n}\n\ndefineSeed(196, 1, makeCastMap([Q$CharSequence]), StringBuffer_0);\n_.toString$ = function toString_13(){\n  return this.impl.string;\n}\n;\nfunction $append_0(this$static, x_0){\n  $append(this$static.impl, x_0);\n  return this$static;\n}\n\nfunction StringBuilder_0(){\n  this.impl = new StringBufferImplAppend_0;\n}\n\ndefineSeed(197, 1, makeCastMap([Q$CharSequence]), StringBuilder_0);\n_.toString$ = function toString_14(){\n  return this.impl.string;\n}\n;\nfunction $clinit_System(){\n  $clinit_System = nullMethod;\n  out_0 = new PrintStream_0;\n}\n\nfunction arraycopy(src_0, srcOfs, dest, destOfs, len){\n  $clinit_System();\n  var destArray, destComp, destEnd, destType, destlen, srcArray, srcComp, srcType, srclen;\n  if (src_0 == null || dest == null) {\n    throw new NullPointerException_0;\n  }\n  srcType = src_0.___clazz$;\n  destType = dest.___clazz$;\n  if ((srcType.modifiers & 4) == 0 || (destType.modifiers & 4) == 0) {\n    throw new ArrayStoreException_1('Must be array types');\n  }\n  srcComp = srcType.componentType;\n  destComp = destType.componentType;\n  if (!((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0)) {\n    throw new ArrayStoreException_1('Array types must match');\n  }\n  srclen = src_0.length;\n  destlen = dest.length;\n  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {\n    throw new IndexOutOfBoundsException_0;\n  }\n  if (((srcComp.modifiers & 1) == 0 || (srcComp.modifiers & 4) != 0) && srcType != destType) {\n    srcArray = dynamicCast(src_0, Q$Object_$1);\n    destArray = dynamicCast(dest, Q$Object_$1);\n    if (src_0 === dest && srcOfs < destOfs) {\n      srcOfs += len;\n      for (destEnd = destOfs + len; destEnd-- > destOfs;) {\n        setCheck(destArray, destEnd, srcArray[--srcOfs]);\n      }\n    }\n     else {\n      for (destEnd = destOfs + len; destOfs < destEnd;) {\n        setCheck(destArray, destOfs++, srcArray[srcOfs++]);\n      }\n    }\n  }\n   else {\n    Array.prototype.splice.apply(dest, [destOfs, len].concat(src_0.slice(srcOfs, srcOfs + len)));\n  }\n}\n\nvar out_0;\nfunction UnsupportedOperationException_0(){\n  RuntimeException_0.call(this);\n}\n\nfunction UnsupportedOperationException_1(message){\n  RuntimeException_1.call(this, message);\n}\n\ndefineSeed(199, 86, makeCastMap([Q$Serializable, Q$Throwable]), UnsupportedOperationException_0, UnsupportedOperationException_1);\nfunction $advanceToFind(iter, o){\n  var t;\n  while (iter.hasNext()) {\n    t = iter.next();\n    if (o == null?t == null:equals__devirtual$(o, t)) {\n      return iter;\n    }\n  }\n  return null;\n}\n\nfunction $toString_0(this$static){\n  var comma, iter, sb, value_0;\n  sb = new StringBuffer_0;\n  comma = null;\n  $append(sb.impl, '[');\n  iter = this$static.iterator();\n  while (iter.hasNext()) {\n    comma != null?($append(sb.impl, comma) , sb):(comma = ', ');\n    value_0 = iter.next();\n    $append(sb.impl, value_0 === this$static?'(this Collection)':'' + value_0);\n  }\n  $append(sb.impl, ']');\n  return sb.impl.string;\n}\n\ndefineSeed(200, 1, {});\n_.add_0 = function add_1(o){\n  throw new UnsupportedOperationException_1('Add not supported on this collection');\n}\n;\n_.contains = function contains_0(o){\n  var iter;\n  iter = $advanceToFind(this.iterator(), o);\n  return !!iter;\n}\n;\n_.toString$ = function toString_15(){\n  return $toString_0(this);\n}\n;\nfunction $implFindEntry(this$static, key){\n  var entry, iter, k;\n  for (iter = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this$static)).this$0); $hasNext(iter.iter);) {\n    entry = iter.last = dynamicCast($next_0(iter.iter), Q$Map$Entry);\n    k = entry.getKey();\n    if (key == null?k == null:equals__devirtual$(key, k)) {\n      return entry;\n    }\n  }\n  return null;\n}\n\nfunction $keySet(this$static){\n  var entrySet;\n  entrySet = new AbstractHashMap$EntrySet_0(this$static);\n  return new AbstractMap$1_0(this$static, entrySet);\n}\n\ndefineSeed(202, 1, makeCastMap([Q$Map]));\n_.containsKey = function containsKey(key){\n  return !!$implFindEntry(this, key);\n}\n;\n_.equals$ = function equals_5(obj){\n  var entry, entry$iterator, otherKey, otherMap, otherValue;\n  if (obj === this) {\n    return true;\n  }\n  if (!instanceOf(obj, Q$Map)) {\n    return false;\n  }\n  otherMap = dynamicCast(obj, Q$Map);\n  if (this.size_0 != otherMap.size_1()) {\n    return false;\n  }\n  for (entry$iterator = otherMap.entrySet_0().iterator(); entry$iterator.hasNext();) {\n    entry = dynamicCast(entry$iterator.next(), Q$Map$Entry);\n    otherKey = entry.getKey();\n    otherValue = entry.getValue();\n    if (!(otherKey == null?this.nullSlotLive:instanceOf(otherKey, Q$String)?$hasStringValue(this, dynamicCast(otherKey, Q$String)):$hasHashValue(this, otherKey, ~~hashCode__devirtual$(otherKey)))) {\n      return false;\n    }\n    if (!equalsWithNullCheck(otherValue, otherKey == null?this.nullSlot:instanceOf(otherKey, Q$String)?$getStringValue(this, dynamicCast(otherKey, Q$String)):$getHashValue(this, otherKey, ~~hashCode__devirtual$(otherKey)))) {\n      return false;\n    }\n  }\n  return true;\n}\n;\n_.get_0 = function get_0(key){\n  var entry;\n  entry = $implFindEntry(this, key);\n  return !entry?null:entry.getValue();\n}\n;\n_.hashCode$ = function hashCode_6(){\n  var entry, entry$iterator, hashCode;\n  hashCode = 0;\n  for (entry$iterator = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this)).this$0); $hasNext(entry$iterator.iter);) {\n    entry = entry$iterator.last = dynamicCast($next_0(entry$iterator.iter), Q$Map$Entry);\n    hashCode += entry.hashCode$();\n    hashCode = ~~hashCode;\n  }\n  return hashCode;\n}\n;\n_.put = function put(key, value_0){\n  throw new UnsupportedOperationException_1('Put not supported on this map');\n}\n;\n_.size_1 = function size_1(){\n  return (new AbstractHashMap$EntrySet_0(this)).this$0.size_0;\n}\n;\n_.toString$ = function toString_16(){\n  var comma, entry, iter, s;\n  s = '{';\n  comma = false;\n  for (iter = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this)).this$0); $hasNext(iter.iter);) {\n    entry = iter.last = dynamicCast($next_0(iter.iter), Q$Map$Entry);\n    comma?(s += ', '):(comma = true);\n    s += '' + entry.getKey();\n    s += '=';\n    s += '' + entry.getValue();\n  }\n  return s + '}';\n}\n;\nfunction $addAllHashEntries(this$static, dest){\n  var hashCodeMap = this$static.hashCodeMap;\n  for (var hashCode in hashCodeMap) {\n    var hashCodeInt = parseInt(hashCode, 10);\n    if (hashCode == hashCodeInt) {\n      var array = hashCodeMap[hashCodeInt];\n      for (var i = 0, c = array.length; i < c; ++i) {\n        dest.add_0(array[i]);\n      }\n    }\n  }\n}\n\nfunction $addAllStringEntries(this$static, dest){\n  var stringMap = this$static.stringMap;\n  for (var key in stringMap) {\n    if (key.charCodeAt(0) == 58) {\n      var entry = new AbstractHashMap$MapEntryString_0(this$static, key.substring(1));\n      dest.add_0(entry);\n    }\n  }\n}\n\nfunction $clearImpl(this$static){\n  this$static.hashCodeMap = [];\n  this$static.stringMap = {};\n  this$static.nullSlotLive = false;\n  this$static.nullSlot = null;\n  this$static.size_0 = 0;\n}\n\nfunction $containsKey(this$static, key){\n  return key == null?this$static.nullSlotLive:instanceOf(key, Q$String)?$hasStringValue(this$static, dynamicCast(key, Q$String)):$hasHashValue(this$static, key, ~~hashCode__devirtual$(key));\n}\n\nfunction $get(this$static, key){\n  return key == null?this$static.nullSlot:instanceOf(key, Q$String)?$getStringValue(this$static, dynamicCast(key, Q$String)):$getHashValue(this$static, key, ~~hashCode__devirtual$(key));\n}\n\nfunction $getHashValue(this$static, key, hashCode){\n  var array = this$static.hashCodeMap[hashCode];\n  if (array) {\n    for (var i = 0, c = array.length; i < c; ++i) {\n      var entry = array[i];\n      var entryKey = entry.getKey();\n      if (this$static.equalsBridge(key, entryKey)) {\n        return entry.getValue();\n      }\n    }\n  }\n  return null;\n}\n\nfunction $getStringValue(this$static, key){\n  return this$static.stringMap[':' + key];\n}\n\nfunction $hasHashValue(this$static, key, hashCode){\n  var array = this$static.hashCodeMap[hashCode];\n  if (array) {\n    for (var i = 0, c = array.length; i < c; ++i) {\n      var entry = array[i];\n      var entryKey = entry.getKey();\n      if (this$static.equalsBridge(key, entryKey)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction $hasStringValue(this$static, key){\n  return ':' + key in this$static.stringMap;\n}\n\nfunction $put(this$static, key, value_0){\n  return key == null?$putNullSlot(this$static, value_0):instanceOf(key, Q$String)?$putStringValue(this$static, dynamicCast(key, Q$String), value_0):$putHashValue(this$static, key, value_0, ~~hashCode__devirtual$(key));\n}\n\nfunction $putHashValue(this$static, key, value_0, hashCode){\n  var array = this$static.hashCodeMap[hashCode];\n  if (array) {\n    for (var i = 0, c = array.length; i < c; ++i) {\n      var entry = array[i];\n      var entryKey = entry.getKey();\n      if (this$static.equalsBridge(key, entryKey)) {\n        var previous = entry.getValue();\n        entry.setValue(value_0);\n        return previous;\n      }\n    }\n  }\n   else {\n    array = this$static.hashCodeMap[hashCode] = [];\n  }\n  var entry = new MapEntryImpl_0(key, value_0);\n  array.push(entry);\n  ++this$static.size_0;\n  return null;\n}\n\nfunction $putNullSlot(this$static, value_0){\n  var result;\n  result = this$static.nullSlot;\n  this$static.nullSlot = value_0;\n  if (!this$static.nullSlotLive) {\n    this$static.nullSlotLive = true;\n    ++this$static.size_0;\n  }\n  return result;\n}\n\nfunction $putStringValue(this$static, key, value_0){\n  var result, stringMap = this$static.stringMap;\n  key = ':' + key;\n  key in stringMap?(result = stringMap[key]):++this$static.size_0;\n  stringMap[key] = value_0;\n  return result;\n}\n\nfunction $remove(this$static, key){\n  return key == null?$removeNullSlot(this$static):instanceOf(key, Q$String)?$removeStringValue(this$static, dynamicCast(key, Q$String)):$removeHashValue(this$static, key, ~~hashCode__devirtual$(key));\n}\n\nfunction $removeHashValue(this$static, key, hashCode){\n  var array = this$static.hashCodeMap[hashCode];\n  if (array) {\n    for (var i = 0, c = array.length; i < c; ++i) {\n      var entry = array[i];\n      var entryKey = entry.getKey();\n      if (this$static.equalsBridge(key, entryKey)) {\n        array.length == 1?delete this$static.hashCodeMap[hashCode]:array.splice(i, 1);\n        --this$static.size_0;\n        return entry.getValue();\n      }\n    }\n  }\n  return null;\n}\n\nfunction $removeNullSlot(this$static){\n  var result;\n  result = this$static.nullSlot;\n  this$static.nullSlot = null;\n  if (this$static.nullSlotLive) {\n    this$static.nullSlotLive = false;\n    --this$static.size_0;\n  }\n  return result;\n}\n\nfunction $removeStringValue(this$static, key){\n  var result, stringMap = this$static.stringMap;\n  key = ':' + key;\n  if (key in stringMap) {\n    result = stringMap[key];\n    --this$static.size_0;\n    delete stringMap[key];\n  }\n  return result;\n}\n\ndefineSeed(201, 202, makeCastMap([Q$Map]));\n_.containsKey = function containsKey_0(key){\n  return $containsKey(this, key);\n}\n;\n_.entrySet_0 = function entrySet_0(){\n  return new AbstractHashMap$EntrySet_0(this);\n}\n;\n_.equalsBridge = function equalsBridge(value1, value2){\n  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);\n}\n;\n_.get_0 = function get_1(key){\n  return $get(this, key);\n}\n;\n_.put = function put_0(key, value_0){\n  return $put(this, key, value_0);\n}\n;\n_.size_1 = function size_2(){\n  return this.size_0;\n}\n;\n_.nullSlotLive = false;\n_.size_0 = 0;\ndefineSeed(204, 200, makeCastMap([Q$Set]));\n_.equals$ = function equals_6(o){\n  var iter, other, otherItem;\n  if (o === this) {\n    return true;\n  }\n  if (!instanceOf(o, Q$Set)) {\n    return false;\n  }\n  other = dynamicCast(o, Q$Set);\n  if (other.size_1() != this.size_1()) {\n    return false;\n  }\n  for (iter = other.iterator(); iter.hasNext();) {\n    otherItem = iter.next();\n    if (!this.contains(otherItem)) {\n      return false;\n    }\n  }\n  return true;\n}\n;\n_.hashCode$ = function hashCode_7(){\n  var hashCode, iter, next;\n  hashCode = 0;\n  for (iter = this.iterator(); iter.hasNext();) {\n    next = iter.next();\n    if (next != null) {\n      hashCode += hashCode__devirtual$(next);\n      hashCode = ~~hashCode;\n    }\n  }\n  return hashCode;\n}\n;\nfunction AbstractHashMap$EntrySet_0(this$0){\n  this.this$0 = this$0;\n}\n\ndefineSeed(203, 204, makeCastMap([Q$Set]), AbstractHashMap$EntrySet_0);\n_.contains = function contains_1(o){\n  var entry, key, value_0;\n  if (instanceOf(o, Q$Map$Entry)) {\n    entry = dynamicCast(o, Q$Map$Entry);\n    key = entry.getKey();\n    if ($containsKey(this.this$0, key)) {\n      value_0 = $get(this.this$0, key);\n      return $equals_0(entry.getValue(), value_0);\n    }\n  }\n  return false;\n}\n;\n_.iterator = function iterator_0(){\n  return new AbstractHashMap$EntrySetIterator_0(this.this$0);\n}\n;\n_.size_1 = function size_3(){\n  return this.this$0.size_0;\n}\n;\nfunction $next(this$static){\n  return this$static.last = dynamicCast($next_0(this$static.iter), Q$Map$Entry);\n}\n\nfunction $remove_0(this$static){\n  if (!this$static.last) {\n    throw new IllegalStateException_1('Must call next() before remove().');\n  }\n   else {\n    $remove_1(this$static.iter);\n    $remove(this$static.this$0, this$static.last.getKey());\n    this$static.last = null;\n  }\n}\n\nfunction AbstractHashMap$EntrySetIterator_0(this$0){\n  var list;\n  this.this$0 = this$0;\n  list = new ArrayList_0;\n  this$0.nullSlotLive && $add_1(list, new AbstractHashMap$MapEntryNull_0(this$0));\n  $addAllStringEntries(this$0, list);\n  $addAllHashEntries(this$0, list);\n  this.iter = new AbstractList$IteratorImpl_0(list);\n}\n\ndefineSeed(205, 1, {}, AbstractHashMap$EntrySetIterator_0);\n_.hasNext = function hasNext(){\n  return $hasNext(this.iter);\n}\n;\n_.next = function next_0(){\n  return $next(this);\n}\n;\n_.last = null;\ndefineSeed(207, 1, makeCastMap([Q$Map$Entry]));\n_.equals$ = function equals_7(other){\n  var entry;\n  if (instanceOf(other, Q$Map$Entry)) {\n    entry = dynamicCast(other, Q$Map$Entry);\n    if (equalsWithNullCheck(this.getKey(), entry.getKey()) && equalsWithNullCheck(this.getValue(), entry.getValue())) {\n      return true;\n    }\n  }\n  return false;\n}\n;\n_.hashCode$ = function hashCode_8(){\n  var keyHash, valueHash;\n  keyHash = 0;\n  valueHash = 0;\n  this.getKey() != null && (keyHash = hashCode__devirtual$(this.getKey()));\n  this.getValue() != null && (valueHash = hashCode__devirtual$(this.getValue()));\n  return keyHash ^ valueHash;\n}\n;\n_.toString$ = function toString_17(){\n  return this.getKey() + '=' + this.getValue();\n}\n;\nfunction AbstractHashMap$MapEntryNull_0(this$0){\n  this.this$0 = this$0;\n}\n\ndefineSeed(206, 207, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryNull_0);\n_.getKey = function getKey(){\n  return null;\n}\n;\n_.getValue = function getValue(){\n  return this.this$0.nullSlot;\n}\n;\n_.setValue = function setValue(object){\n  return $putNullSlot(this.this$0, object);\n}\n;\nfunction AbstractHashMap$MapEntryString_0(this$0, key){\n  this.this$0 = this$0;\n  this.key = key;\n}\n\ndefineSeed(208, 207, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryString_0);\n_.getKey = function getKey_0(){\n  return this.key;\n}\n;\n_.getValue = function getValue_0(){\n  return $getStringValue(this.this$0, this.key);\n}\n;\n_.setValue = function setValue_0(object){\n  return $putStringValue(this.this$0, this.key, object);\n}\n;\nfunction checkIndex(index_0, size_0){\n  (index_0 < 0 || index_0 >= size_0) && indexOutOfBounds(index_0, size_0);\n}\n\nfunction indexOutOfBounds(index_0, size_0){\n  throw new IndexOutOfBoundsException_1('Index: ' + index_0 + ', Size: ' + size_0);\n}\n\ndefineSeed(209, 200, makeCastMap([Q$List]));\n_.add_0 = function add_2(obj){\n  $add_0(this, this.size_1(), obj);\n  return true;\n}\n;\n_.equals$ = function equals_8(o){\n  var elem, elemOther, iter, iterOther, other;\n  if (o === this) {\n    return true;\n  }\n  if (!instanceOf(o, Q$List)) {\n    return false;\n  }\n  other = dynamicCast(o, Q$List);\n  if (this.size_1() != other.size_1()) {\n    return false;\n  }\n  iter = new AbstractList$IteratorImpl_0(this);\n  iterOther = other.iterator();\n  while (iter.i < iter.this$0.size_0) {\n    elem = $next_0(iter);\n    elemOther = iterOther.next();\n    if (!(elem == null?elemOther == null:equals__devirtual$(elem, elemOther))) {\n      return false;\n    }\n  }\n  return true;\n}\n;\n_.hashCode$ = function hashCode_9(){\n  var iter, k, obj;\n  k = 1;\n  iter = new AbstractList$IteratorImpl_0(this);\n  while (iter.i < iter.this$0.size_0) {\n    obj = $next_0(iter);\n    k = 31 * k + (obj == null?0:hashCode__devirtual$(obj));\n    k = ~~k;\n  }\n  return k;\n}\n;\n_.iterator = function iterator_1(){\n  return new AbstractList$IteratorImpl_0(this);\n}\n;\nfunction $hasNext(this$static){\n  return this$static.i < this$static.this$0.size_0;\n}\n\nfunction $next_0(this$static){\n  if (this$static.i >= this$static.this$0.size_0) {\n    throw new NoSuchElementException_0;\n  }\n  return $get_0(this$static.this$0, this$static.last = this$static.i++);\n}\n\nfunction $remove_1(this$static){\n  if (this$static.last < 0) {\n    throw new IllegalStateException_0;\n  }\n  $remove_2(this$static.this$0, this$static.last);\n  this$static.i = this$static.last;\n  this$static.last = -1;\n}\n\nfunction AbstractList$IteratorImpl_0(this$0){\n  this.this$0 = this$0;\n}\n\ndefineSeed(210, 1, {}, AbstractList$IteratorImpl_0);\n_.hasNext = function hasNext_0(){\n  return $hasNext(this);\n}\n;\n_.next = function next_1(){\n  return $next_0(this);\n}\n;\n_.i = 0;\n_.last = -1;\nfunction $iterator(this$static){\n  var outerIter;\n  outerIter = new AbstractHashMap$EntrySetIterator_0(this$static.val$entrySet.this$0);\n  return new AbstractMap$1$1_0(outerIter);\n}\n\nfunction AbstractMap$1_0(this$0, val$entrySet){\n  this.this$0 = this$0;\n  this.val$entrySet = val$entrySet;\n}\n\ndefineSeed(211, 204, makeCastMap([Q$Set]), AbstractMap$1_0);\n_.contains = function contains_2(key){\n  return $containsKey(this.this$0, key);\n}\n;\n_.iterator = function iterator_2(){\n  return $iterator(this);\n}\n;\n_.size_1 = function size_4(){\n  return this.val$entrySet.this$0.size_0;\n}\n;\nfunction $next_1(this$static){\n  var entry;\n  entry = $next(this$static.val$outerIter);\n  return entry.getKey();\n}\n\nfunction AbstractMap$1$1_0(val$outerIter){\n  this.val$outerIter = val$outerIter;\n}\n\ndefineSeed(212, 1, {}, AbstractMap$1$1_0);\n_.hasNext = function hasNext_1(){\n  return $hasNext(this.val$outerIter.iter);\n}\n;\n_.next = function next_2(){\n  return $next_1(this);\n}\n;\nfunction $add_0(this$static, index_0, o){\n  (index_0 < 0 || index_0 > this$static.size_0) && indexOutOfBounds(index_0, this$static.size_0);\n  splice_1(this$static.array, index_0, 0, o);\n  ++this$static.size_0;\n}\n\nfunction $add_1(this$static, o){\n  setCheck(this$static.array, this$static.size_0++, o);\n  return true;\n}\n\nfunction $clear_0(this$static){\n  this$static.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable]), Q$Object, 0, 0);\n  this$static.size_0 = 0;\n}\n\nfunction $get_0(this$static, index_0){\n  checkIndex(index_0, this$static.size_0);\n  return this$static.array[index_0];\n}\n\nfunction $indexOf_0(this$static, o, index_0){\n  for (; index_0 < this$static.size_0; ++index_0) {\n    if (equalsWithNullCheck(o, this$static.array[index_0])) {\n      return index_0;\n    }\n  }\n  return -1;\n}\n\nfunction $remove_2(this$static, index_0){\n  var previous;\n  previous = (checkIndex(index_0, this$static.size_0) , this$static.array[index_0]);\n  splice_0(this$static.array, index_0, 1);\n  --this$static.size_0;\n  return previous;\n}\n\nfunction $toArray(this$static, out){\n  var i;\n  out.length < this$static.size_0 && (out = createFrom(out, this$static.size_0));\n  for (i = 0; i < this$static.size_0; ++i) {\n    setCheck(out, i, this$static.array[i]);\n  }\n  out.length > this$static.size_0 && setCheck(out, this$static.size_0, null);\n  return out;\n}\n\nfunction ArrayList_0(){\n  this.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable]), Q$Object, 0, 0);\n}\n\nfunction splice_0(array, index_0, deleteCount){\n  array.splice(index_0, deleteCount);\n}\n\nfunction splice_1(array, index_0, deleteCount, value_0){\n  array.splice(index_0, deleteCount, value_0);\n}\n\ndefineSeed(213, 209, makeCastMap([Q$Serializable, Q$List, Q$RandomAccess]), ArrayList_0);\n_.add_0 = function add_3(o){\n  return $add_1(this, o);\n}\n;\n_.contains = function contains_3(o){\n  return $indexOf_0(this, o, 0) != -1;\n}\n;\n_.get_1 = function get_2(index_0){\n  return $get_0(this, index_0);\n}\n;\n_.size_1 = function size_5(){\n  return this.size_0;\n}\n;\n_.size_0 = 0;\nfunction unmodifiableList(list){\n  return instanceOf(list, Q$RandomAccess)?new Collections$UnmodifiableRandomAccessList_0(list):new Collections$UnmodifiableList_0(list);\n}\n\nfunction Collections$UnmodifiableCollection_0(coll){\n  this.coll = coll;\n}\n\ndefineSeed(215, 1, {});\n_.add_0 = function add_4(o){\n  throw new UnsupportedOperationException_0;\n}\n;\n_.iterator = function iterator_3(){\n  return new Collections$UnmodifiableCollectionIterator_0(this.coll.iterator());\n}\n;\n_.size_1 = function size_6(){\n  return this.coll.size_1();\n}\n;\n_.toString$ = function toString_18(){\n  return this.coll.toString$();\n}\n;\nfunction Collections$UnmodifiableCollectionIterator_0(it){\n  this.it = it;\n}\n\ndefineSeed(216, 1, {}, Collections$UnmodifiableCollectionIterator_0);\n_.hasNext = function hasNext_2(){\n  return this.it.hasNext();\n}\n;\n_.next = function next_3(){\n  return this.it.next();\n}\n;\nfunction Collections$UnmodifiableList_0(list){\n  Collections$UnmodifiableCollection_0.call(this, list);\n  this.list = list;\n}\n\ndefineSeed(217, 215, makeCastMap([Q$List]), Collections$UnmodifiableList_0);\n_.equals$ = function equals_9(o){\n  return this.list.equals$(o);\n}\n;\n_.get_1 = function get_3(index_0){\n  return this.list.get_1(index_0);\n}\n;\n_.hashCode$ = function hashCode_10(){\n  return this.list.hashCode$();\n}\n;\nfunction Collections$UnmodifiableMap_0(map_0){\n  this.map_0 = map_0;\n}\n\ndefineSeed(218, 1, makeCastMap([Q$Map]), Collections$UnmodifiableMap_0);\n_.containsKey = function containsKey_1(key){\n  return this.map_0.containsKey(key);\n}\n;\n_.entrySet_0 = function entrySet_1(){\n  !this.entrySet && (this.entrySet = new Collections$UnmodifiableMap$UnmodifiableEntrySet_0(this.map_0.entrySet_0()));\n  return this.entrySet;\n}\n;\n_.equals$ = function equals_10(o){\n  return this.map_0.equals$(o);\n}\n;\n_.get_0 = function get_4(key){\n  return this.map_0.get_0(key);\n}\n;\n_.hashCode$ = function hashCode_11(){\n  return this.map_0.hashCode$();\n}\n;\n_.put = function put_1(key, value_0){\n  throw new UnsupportedOperationException_0;\n}\n;\n_.size_1 = function size_7(){\n  return this.map_0.size_1();\n}\n;\n_.toString$ = function toString_19(){\n  return this.map_0.toString$();\n}\n;\ndefineSeed(220, 215, makeCastMap([Q$Set]));\n_.equals$ = function equals_11(o){\n  return this.coll.equals$(o);\n}\n;\n_.hashCode$ = function hashCode_12(){\n  return this.coll.hashCode$();\n}\n;\nfunction Collections$UnmodifiableMap$UnmodifiableEntrySet_0(s){\n  Collections$UnmodifiableCollection_0.call(this, s);\n}\n\ndefineSeed(219, 220, makeCastMap([Q$Set]), Collections$UnmodifiableMap$UnmodifiableEntrySet_0);\n_.iterator = function iterator_4(){\n  var it;\n  it = this.coll.iterator();\n  return new Collections$UnmodifiableMap$UnmodifiableEntrySet$1_0(it);\n}\n;\nfunction Collections$UnmodifiableMap$UnmodifiableEntrySet$1_0(val$it){\n  this.val$it = val$it;\n}\n\ndefineSeed(221, 1, {}, Collections$UnmodifiableMap$UnmodifiableEntrySet$1_0);\n_.hasNext = function hasNext_3(){\n  return this.val$it.hasNext();\n}\n;\n_.next = function next_4(){\n  return new Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry_0(dynamicCast(this.val$it.next(), Q$Map$Entry));\n}\n;\nfunction Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry_0(entry){\n  this.entry = entry;\n}\n\ndefineSeed(222, 1, makeCastMap([Q$Map$Entry]), Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry_0);\n_.equals$ = function equals_12(o){\n  return this.entry.equals$(o);\n}\n;\n_.getKey = function getKey_1(){\n  return this.entry.getKey();\n}\n;\n_.getValue = function getValue_1(){\n  return this.entry.getValue();\n}\n;\n_.hashCode$ = function hashCode_13(){\n  return this.entry.hashCode$();\n}\n;\n_.setValue = function setValue_1(value_0){\n  throw new UnsupportedOperationException_0;\n}\n;\n_.toString$ = function toString_20(){\n  return this.entry.toString$();\n}\n;\nfunction Collections$UnmodifiableRandomAccessList_0(list){\n  Collections$UnmodifiableList_0.call(this, list);\n}\n\ndefineSeed(223, 217, makeCastMap([Q$List, Q$RandomAccess]), Collections$UnmodifiableRandomAccessList_0);\nfunction $toString_1(this$static){\n  var hourOffset, minuteOffset, offset;\n  offset = -this$static.jsdate.getTimezoneOffset();\n  hourOffset = (offset >= 0?'+':'') + ~~(offset / 60);\n  minuteOffset = (offset < 0?-offset:offset) % 60 < 10?'0' + (offset < 0?-offset:offset) % 60:'' + (offset < 0?-offset:offset) % 60;\n  return ($clinit_Date$StringData() , DAYS)[this$static.jsdate.getDay()] + ' ' + MONTHS[this$static.jsdate.getMonth()] + ' ' + padTwo(this$static.jsdate.getDate()) + ' ' + padTwo(this$static.jsdate.getHours()) + ':' + padTwo(this$static.jsdate.getMinutes()) + ':' + padTwo(this$static.jsdate.getSeconds()) + ' GMT' + hourOffset + minuteOffset + ' ' + this$static.jsdate.getFullYear();\n}\n\nfunction Date_1(){\n  this.jsdate = new Date;\n}\n\nfunction Date_2(date){\n  this.jsdate = create(toDouble(date));\n}\n\nfunction padTwo(number){\n  return number < 10?'0' + number:'' + number;\n}\n\ndefineSeed(224, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Date]), Date_1, Date_2);\n_.equals$ = function equals_13(obj){\n  return instanceOf(obj, Q$Date) && eq(fromDouble(this.jsdate.getTime()), fromDouble(dynamicCast(obj, Q$Date).jsdate.getTime()));\n}\n;\n_.hashCode$ = function hashCode_14(){\n  var time;\n  time = fromDouble(this.jsdate.getTime());\n  return toInt(xor(time, shru(time, 32)));\n}\n;\n_.toString$ = function toString_21(){\n  return $toString_1(this);\n}\n;\nfunction $clinit_Date$StringData(){\n  $clinit_Date$StringData = nullMethod;\n  DAYS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable]), Q$String, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);\n  MONTHS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable]), Q$String, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);\n}\n\nvar DAYS, MONTHS;\nfunction $equals_0(value1, value2){\n  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);\n}\n\nfunction HashMap_0(){\n  $clearImpl(this);\n}\n\ndefineSeed(226, 201, makeCastMap([Q$Serializable, Q$Map]), HashMap_0);\nfunction $add_2(this$static, o){\n  var old;\n  old = $put(this$static.map_0, o, this$static);\n  return old == null;\n}\n\nfunction HashSet_0(){\n  this.map_0 = new HashMap_0;\n}\n\ndefineSeed(227, 204, makeCastMap([Q$Serializable, Q$Set]), HashSet_0);\n_.add_0 = function add_5(o){\n  return $add_2(this, o);\n}\n;\n_.contains = function contains_4(o){\n  return $containsKey(this.map_0, o);\n}\n;\n_.iterator = function iterator_5(){\n  return $iterator($keySet(this.map_0));\n}\n;\n_.size_1 = function size_8(){\n  return this.map_0.size_0;\n}\n;\n_.toString$ = function toString_22(){\n  return $toString_0($keySet(this.map_0));\n}\n;\nfunction MapEntryImpl_0(key, value_0){\n  this.key = key;\n  this.value_0 = value_0;\n}\n\ndefineSeed(228, 207, makeCastMap([Q$Map$Entry]), MapEntryImpl_0);\n_.getKey = function getKey_2(){\n  return this.key;\n}\n;\n_.getValue = function getValue_2(){\n  return this.value_0;\n}\n;\n_.setValue = function setValue_2(value_0){\n  var old;\n  old = this.value_0;\n  this.value_0 = value_0;\n  return old;\n}\n;\nfunction NoSuchElementException_0(){\n  RuntimeException_0.call(this);\n}\n\ndefineSeed(229, 86, makeCastMap([Q$Serializable, Q$Throwable]), NoSuchElementException_0);\nfunction equalsWithNullCheck(a, b){\n  return maskUndefined(a) === maskUndefined(b) || a != null && equals__devirtual$(a, b);\n}\n\nfunction $clinit_Level(){\n  $clinit_Level = nullMethod;\n  ALL = new Level$LevelAll_0;\n  CONFIG = new Level$LevelConfig_0;\n  FINE = new Level$LevelFine_0;\n  FINER = new Level$LevelFiner_0;\n  FINEST = new Level$LevelFinest_0;\n  INFO = new Level$LevelInfo_0;\n  OFF = new Level$LevelOff_0;\n  SEVERE = new Level$LevelSevere_0;\n  WARNING = new Level$LevelWarning_0;\n}\n\ndefineSeed(231, 1, makeCastMap([Q$Serializable]));\n_.getName = function getName(){\n  return 'DUMMY';\n}\n;\n_.intValue = function intValue(){\n  return -1;\n}\n;\n_.toString$ = function toString_23(){\n  return this.getName();\n}\n;\nvar ALL, CONFIG, FINE, FINER, FINEST, INFO, OFF, SEVERE, WARNING;\nfunction Level$LevelAll_0(){\n}\n\ndefineSeed(232, 231, makeCastMap([Q$Serializable]), Level$LevelAll_0);\n_.getName = function getName_0(){\n  return 'ALL';\n}\n;\n_.intValue = function intValue_0(){\n  return -2147483648;\n}\n;\n",
"function Level$LevelConfig_0(){\n}\n\ndefineSeed(233, 231, makeCastMap([Q$Serializable]), Level$LevelConfig_0);\n_.getName = function getName_1(){\n  return 'CONFIG';\n}\n;\n_.intValue = function intValue_1(){\n  return 700;\n}\n;\nfunction Level$LevelFine_0(){\n}\n\ndefineSeed(234, 231, makeCastMap([Q$Serializable]), Level$LevelFine_0);\n_.getName = function getName_2(){\n  return 'FINE';\n}\n;\n_.intValue = function intValue_2(){\n  return 500;\n}\n;\nfunction Level$LevelFiner_0(){\n}\n\ndefineSeed(235, 231, makeCastMap([Q$Serializable]), Level$LevelFiner_0);\n_.getName = function getName_3(){\n  return 'FINER';\n}\n;\n_.intValue = function intValue_3(){\n  return 400;\n}\n;\nfunction Level$LevelFinest_0(){\n}\n\ndefineSeed(236, 231, makeCastMap([Q$Serializable]), Level$LevelFinest_0);\n_.getName = function getName_4(){\n  return 'FINEST';\n}\n;\n_.intValue = function intValue_4(){\n  return 300;\n}\n;\nfunction Level$LevelInfo_0(){\n}\n\ndefineSeed(237, 231, makeCastMap([Q$Serializable]), Level$LevelInfo_0);\n_.getName = function getName_5(){\n  return 'INFO';\n}\n;\n_.intValue = function intValue_5(){\n  return 800;\n}\n;\nfunction Level$LevelOff_0(){\n}\n\ndefineSeed(238, 231, makeCastMap([Q$Serializable]), Level$LevelOff_0);\n_.getName = function getName_6(){\n  return 'OFF';\n}\n;\n_.intValue = function intValue_6(){\n  return 2147483647;\n}\n;\nfunction Level$LevelSevere_0(){\n}\n\ndefineSeed(239, 231, makeCastMap([Q$Serializable]), Level$LevelSevere_0);\n_.getName = function getName_7(){\n  return 'SEVERE';\n}\n;\n_.intValue = function intValue_7(){\n  return 1000;\n}\n;\nfunction Level$LevelWarning_0(){\n}\n\ndefineSeed(240, 231, makeCastMap([Q$Serializable]), Level$LevelWarning_0);\n_.getName = function getName_8(){\n  return 'WARNING';\n}\n;\n_.intValue = function intValue_8(){\n  return 900;\n}\n;\nfunction $addLogger(this$static, logger){\n  if ($getLogger(this$static, logger.impl.name_0)) {\n    return false;\n  }\n  $addLoggerWithoutDuplicationChecking(this$static, logger);\n  return true;\n}\n\nfunction $addLoggerWithoutDuplicationChecking(this$static, logger){\n  var name_0, parent_0, parentName;\n  name_0 = logger.impl.name_0;\n  parentName = $substring_0(name_0, 0, max_1(0, $lastIndexOf(name_0, fromCodePoint(46))));\n  parent_0 = $getOrAddLogger(this$static, parentName);\n  $put(this$static.loggerList, logger.impl.name_0, logger);\n  $setParent(logger.impl, parent_0);\n}\n\nfunction $getLogger(this$static, name_0){\n  return dynamicCast($get(this$static.loggerList, name_0), Q$Logger);\n}\n\nfunction $getOrAddLogger(this$static, name_0){\n  var logger, newLogger;\n  logger = dynamicCast($get(this$static.loggerList, name_0), Q$Logger);\n  if (!logger) {\n    newLogger = new Logger_0(name_0);\n    $addLoggerWithoutDuplicationChecking(this$static, newLogger);\n    return newLogger;\n  }\n  return logger;\n}\n\nfunction LogManager_0(){\n  this.loggerList = new HashMap_0;\n  this.rootLogger = new LogManager$RootLogger_0;\n  $put(this.loggerList, '', this.rootLogger);\n}\n\ndefineSeed(241, 1, {}, LogManager_0);\nvar singleton;\nfunction LogManager$RootLogger_0(){\n  $clinit_Logger();\n  Logger_0.call(this, '');\n  $setLevel_1(this, ($clinit_Level() , ALL));\n}\n\ndefineSeed(242, 158, makeCastMap([Q$Logger]), LogManager$RootLogger_0);\nfunction $setLoggerName(this$static, newName){\n  this$static.loggerName = newName;\n}\n\nfunction LogRecord_0(level, msg){\n  this.level = level;\n  this.msg = msg;\n  this.millis = fromDouble((new Date_1).jsdate.getTime());\n}\n\ndefineSeed(243, 1, makeCastMap([Q$Serializable]), LogRecord_0);\n_.loggerName = '';\n_.millis = P0_longLit;\n_.thrown = null;\nvar $entry = registerEntry();\nfunction gwtOnLoad(errFn, modName, modBase, softPermutationId){\n  $moduleName = modName;\n  $moduleBase = modBase;\n  if (errFn)\n    try {\n      $entry(init)();\n    }\n     catch (e) {\n      errFn(modName);\n    }\n   else {\n    $entry(init)();\n  }\n}\n\nvar Ljava_lang_Object_2_classLit = createForClass('java.lang.', 'Object', 1), Lcom_github_rma350_jgraphv_web_client_JGraphVWeb_2_classLit = createForClass('com.github.rma350.jgraphv.web.client.', 'JGraphVWeb', 71), Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass('com.google.gwt.core.client.', 'JavaScriptObject$', 75), Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass('com.google.gwt.core.client.', 'Scheduler', 93), I_classLit = createForPrimitive('int', ' I'), _3I_classLit = createForArray('', '[I', 249, I_classLit), _3Ljava_lang_Object_2_classLit = createForArray('[Ljava.lang.', 'Object;', 247, Ljava_lang_Object_2_classLit), Ljava_lang_Throwable_2_classLit = createForClass('java.lang.', 'Throwable', 88), Ljava_lang_Exception_2_classLit = createForClass('java.lang.', 'Exception', 87), Ljava_lang_RuntimeException_2_classLit = createForClass('java.lang.', 'RuntimeException', 86), Ljava_lang_StackTraceElement_2_classLit = createForClass('java.lang.', 'StackTraceElement', 194), _3Ljava_lang_StackTraceElement_2_classLit = createForArray('[Ljava.lang.', 'StackTraceElement;', 250, Ljava_lang_StackTraceElement_2_classLit), Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForClass('com.google.gwt.lang.', 'LongLibBase$LongEmul', null), _3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForArray('[Lcom.google.gwt.lang.', 'LongLibBase$LongEmul;', 251, Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit), Lcom_google_gwt_lang_SeedUtil_2_classLit = createForClass('com.google.gwt.lang.', 'SeedUtil', 133), Lcom_google_gwt_logging_client_LogConfiguration_2_classLit = createForClass('com.google.gwt.logging.client.', 'LogConfiguration', null), Lcom_google_gwt_logging_client_LogConfiguration$LogConfigurationImplRegular_2_classLit = createForClass('com.google.gwt.logging.client.', 'LogConfiguration$LogConfigurationImplRegular', 151), Lcom_google_gwt_logging_client_LogConfiguration$1_2_classLit = createForClass('com.google.gwt.logging.client.', 'LogConfiguration$1', 150), Ljava_lang_Enum_2_classLit = createForClass('java.lang.', 'Enum', 64), Ljava_lang_Boolean_2_classLit = createForClass('java.lang.', 'Boolean', 180), Ljava_lang_Number_2_classLit = createForClass('java.lang.', 'Number', 184), C_classLit = createForPrimitive('char', ' C'), _3C_classLit = createForArray('', '[C', 252, C_classLit), Ljava_lang_Class_2_classLit = createForClass('java.lang.', 'Class', 181), F_classLit = createForPrimitive('float', ' F'), Ljava_lang_Float_2_classLit = createForClass('java.lang.', 'Float', 185), Ljava_lang_Integer_2_classLit = createForClass('java.lang.', 'Integer', 189), _3Ljava_lang_Integer_2_classLit = createForArray('[Ljava.lang.', 'Integer;', 253, Ljava_lang_Integer_2_classLit), Ljava_lang_String_2_classLit = createForClass('java.lang.', 'String', 2), _3Ljava_lang_String_2_classLit = createForArray('[Ljava.lang.', 'String;', 248, Ljava_lang_String_2_classLit), Ljava_lang_ClassCastException_2_classLit = createForClass('java.lang.', 'ClassCastException', 182), Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass('com.google.gwt.core.client.', 'JavaScriptException', 85), Ljava_lang_StringBuilder_2_classLit = createForClass('java.lang.', 'StringBuilder', 197), Ljava_lang_ArrayStoreException_2_classLit = createForClass('java.lang.', 'ArrayStoreException', 179), Ljava_util_logging_Logger_2_classLit = createForClass('java.util.logging.', 'Logger', 158), Ljava_lang_NullPointerException_2_classLit = createForClass('java.lang.', 'NullPointerException', 192), Ljava_lang_IllegalArgumentException_2_classLit = createForClass('java.lang.', 'IllegalArgumentException', 186), Ljava_lang_ArithmeticException_2_classLit = createForClass('java.lang.', 'ArithmeticException', 178), Lcom_google_gwt_core_client_impl_StringBufferImpl_2_classLit = createForClass('com.google.gwt.core.client.impl.', 'StringBufferImpl', 100), Lcom_google_gwt_logging_impl_LoggerImplRegular_2_classLit = createForClass('com.google.gwt.logging.impl.', 'LoggerImplRegular', 156), Ljava_util_logging_Handler_2_classLit = createForClass('java.util.logging.', 'Handler', 137), _3Ljava_util_logging_Handler_2_classLit = createForArray('[Ljava.util.logging.', 'Handler;', 254, Ljava_util_logging_Handler_2_classLit), Lcom_google_gwt_core_client_impl_StringBufferImplAppend_2_classLit = createForClass('com.google.gwt.core.client.impl.', 'StringBufferImplAppend', 101), Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass('com.google.gwt.core.client.impl.', 'SchedulerImpl', 95), Ljava_util_AbstractCollection_2_classLit = createForClass('java.util.', 'AbstractCollection', 200), Ljava_util_AbstractList_2_classLit = createForClass('java.util.', 'AbstractList', 209), Ljava_util_ArrayList_2_classLit = createForClass('java.util.', 'ArrayList', 213), Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass('java.util.', 'AbstractList$IteratorImpl', 210), Lcom_github_rma350_jgraphv_web_client_coredeps_WebGL_2_classLit = createForClass('com.github.rma350.jgraphv.web.client.coredeps.', 'WebGL', 72), Lcom_github_rma350_jgraphv_core_engine_Engine_2_classLit = createForClass('com.github.rma350.jgraphv.core.engine.', 'Engine', 19), Lcom_github_rma350_jgraphv_core_portable_impl_SynchronousTaskRunner_2_classLit = createForClass('com.github.rma350.jgraphv.core.portable.impl.', 'SynchronousTaskRunner', 46), Lcom_github_rma350_jgraphv_core_portable_impl_SynchronousTaskRunner$TaskEntry_2_classLit = createForClass('com.github.rma350.jgraphv.core.portable.impl.', 'SynchronousTaskRunner$TaskEntry', 47), Lcom_github_rma350_jgraphv_core_demo_Demo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'Demo', 6), Lcom_github_rma350_jgraphv_core_demo_Demo$Param_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'Demo$Param', 9), Lcom_github_rma350_jgraphv_core_demo_Demo$IntParam_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'Demo$IntParam', 11), Lcom_github_rma350_jgraphv_core_demo_Demo$FloatParam_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'Demo$FloatParam', 10), Lcom_github_rma350_jgraphv_core_demo_Demo$BooleanParam_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'Demo$BooleanParam', 8), Lcom_github_rma350_jgraphv_core_engine_Camera_2_classLit = createForClass('com.github.rma350.jgraphv.core.engine.', 'Camera', 18), Ljava_util_logging_Level_2_classLit = createForClass('java.util.logging.', 'Level', 231), Ljava_util_logging_Level$LevelAll_2_classLit = createForClass('java.util.logging.', 'Level$LevelAll', 232), Ljava_util_logging_Level$LevelConfig_2_classLit = createForClass('java.util.logging.', 'Level$LevelConfig', 233), Ljava_util_logging_Level$LevelFine_2_classLit = createForClass('java.util.logging.', 'Level$LevelFine', 234), Ljava_util_logging_Level$LevelFiner_2_classLit = createForClass('java.util.logging.', 'Level$LevelFiner', 235), Ljava_util_logging_Level$LevelFinest_2_classLit = createForClass('java.util.logging.', 'Level$LevelFinest', 236), Ljava_util_logging_Level$LevelInfo_2_classLit = createForClass('java.util.logging.', 'Level$LevelInfo', 237), Ljava_util_logging_Level$LevelOff_2_classLit = createForClass('java.util.logging.', 'Level$LevelOff', 238), Ljava_util_logging_Level$LevelSevere_2_classLit = createForClass('java.util.logging.', 'Level$LevelSevere', 239), Ljava_util_logging_Level$LevelWarning_2_classLit = createForClass('java.util.logging.', 'Level$LevelWarning', 240), Ljava_util_logging_LogManager_2_classLit = createForClass('java.util.logging.', 'LogManager', 241), Ljava_util_logging_LogManager$RootLogger_2_classLit = createForClass('java.util.logging.', 'LogManager$RootLogger', 242), Lcom_google_gwt_logging_impl_LoggerWithExposedConstructor_2_classLit = createForClass('com.google.gwt.logging.impl.', 'LoggerWithExposedConstructor', 157), Lcom_github_rma350_jgraphv_web_client_coredeps_WebGLObjects_2_classLit = createForClass('com.github.rma350.jgraphv.web.client.coredeps.', 'WebGLObjects', 73), Ljava_util_AbstractMap_2_classLit = createForClass('java.util.', 'AbstractMap', 202), Ljava_util_AbstractHashMap_2_classLit = createForClass('java.util.', 'AbstractHashMap', 201), Ljava_util_HashMap_2_classLit = createForClass('java.util.', 'HashMap', 226), Ljava_util_AbstractSet_2_classLit = createForClass('java.util.', 'AbstractSet', 204), Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass('java.util.', 'AbstractHashMap$EntrySet', 203), Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass('java.util.', 'AbstractHashMap$EntrySetIterator', 205), Ljava_util_AbstractMapEntry_2_classLit = createForClass('java.util.', 'AbstractMapEntry', 207), Ljava_util_AbstractHashMap$MapEntryNull_2_classLit = createForClass('java.util.', 'AbstractHashMap$MapEntryNull', 206), Ljava_util_AbstractHashMap$MapEntryString_2_classLit = createForClass('java.util.', 'AbstractHashMap$MapEntryString', 208), Ljava_util_AbstractMap$1_2_classLit = createForClass('java.util.', 'AbstractMap$1', 211), Ljava_util_AbstractMap$1$1_2_classLit = createForClass('java.util.', 'AbstractMap$1$1', 212), Lcom_github_rma350_jgraphv_core_shapes_PointsShader_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'PointsShader', 67), Lcom_github_rma350_jgraphv_core_shapes_CirclesShader_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'CirclesShader', 57), Lcom_github_rma350_jgraphv_core_shapes_LinesShader_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'LinesShader', 62), Lcom_github_rma350_jgraphv_core_shapes_TriangleShader_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'TriangleShader', 70), Lcom_github_rma350_jgraphv_core_shapes_ArcShader_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'ArcShader', 53), Lcom_github_rma350_jgraphv_core_engine_Scene_2_classLit = createForClass('com.github.rma350.jgraphv.core.engine.', 'Scene', 20), Lcom_github_rma350_jgraphv_core_demo_ArcDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'ArcDemo', 5), _3F_classLit = createForArray('', '[F', 255, F_classLit), Lcom_github_rma350_jgraphv_core_demo_ConnectTwoPointsDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'ConnectTwoPointsDemo', 7), Lcom_github_rma350_jgraphv_core_demo_DirectedGeometricGraph_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'DirectedGeometricGraph', 12), Lcom_github_rma350_jgraphv_core_demo_ForceDirectedErdosRenyiDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'ForceDirectedErdosRenyiDemo', 13), Lcom_github_rma350_jgraphv_core_demo_GraphArcDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'GraphArcDemo', 14), Lcom_github_rma350_jgraphv_core_demo_RandomCirclesDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'RandomCirclesDemo', 15), Lcom_github_rma350_jgraphv_core_demo_TwoPointsDemo_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'TwoPointsDemo', 16), Lcom_github_rma350_jgraphv_core_demo_UndirectedGeometricGraph_2_classLit = createForClass('com.github.rma350.jgraphv.core.demo.', 'UndirectedGeometricGraph', 17), Ljava_io_OutputStream_2_classLit = createForClass('java.io.', 'OutputStream', 148), Ljava_io_FilterOutputStream_2_classLit = createForClass('java.io.', 'FilterOutputStream', 147), Ljava_io_PrintStream_2_classLit = createForClass('java.io.', 'PrintStream', 146), Ljava_util_logging_LogRecord_2_classLit = createForClass('java.util.logging.', 'LogRecord', 243), Lcom_google_gwt_logging_client_ConsoleLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'ConsoleLogHandler', 136), Lcom_google_gwt_logging_client_DevelopmentModeLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'DevelopmentModeLogHandler', 138), Lcom_google_gwt_logging_client_FirebugLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'FirebugLogHandler', 139), Lcom_google_gwt_logging_client_SystemLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'SystemLogHandler', 154), Lcom_google_gwt_logging_client_NullLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'NullLogHandler', 152), Lcom_google_gwt_logging_client_NullLoggingPopup_2_classLit = createForClass('com.google.gwt.logging.client.', 'NullLoggingPopup', 153), Lcom_google_gwt_logging_client_HasWidgetsLogHandler_2_classLit = createForClass('com.google.gwt.logging.client.', 'HasWidgetsLogHandler', 140), Ljava_lang_StringBuffer_2_classLit = createForClass('java.lang.', 'StringBuffer', 196), Lcom_github_rma350_jgraphv_core_shapes_ShaderUtil_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'ShaderUtil', null), Ljava_util_HashSet_2_classLit = createForClass('java.util.', 'HashSet', 227), Ljava_lang_UnsupportedOperationException_2_classLit = createForClass('java.lang.', 'UnsupportedOperationException', 199), Ljava_util_Date_2_classLit = createForClass('java.util.', 'Date', 224), Lcom_google_gwt_core_shared_SerializableThrowable_2_classLit = createForClass('com.google.gwt.core.shared.', 'SerializableThrowable', 103), Ljava_util_logging_Formatter_2_classLit = createForClass('java.util.logging.', 'Formatter', 143), Lcom_google_gwt_logging_impl_FormatterImpl_2_classLit = createForClass('com.google.gwt.logging.impl.', 'FormatterImpl', 142), Lcom_google_gwt_logging_client_TextLogFormatter_2_classLit = createForClass('com.google.gwt.logging.client.', 'TextLogFormatter', 155), Lcom_google_gwt_logging_impl_StackTracePrintStream_2_classLit = createForClass('com.google.gwt.logging.impl.', 'StackTracePrintStream', 145), Lcom_google_gwt_logging_client_HtmlLogFormatter_2_classLit = createForClass('com.google.gwt.logging.client.', 'HtmlLogFormatter', 141), Lcom_google_gwt_logging_client_HtmlLogFormatter$1_2_classLit = createForClass('com.google.gwt.logging.client.', 'HtmlLogFormatter$1', 144), Lcom_github_rma350_jgraphv_core_shapes_ArcBuilder_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'ArcBuilder', 51), Lcom_github_rma350_jgraphv_core_shapes_ArcBufferBuilder_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'ArcBufferBuilder', 50), Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'NativeShapeBuffer', 49), Lcom_github_rma350_jgraphv_core_shapes_ArcBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'ArcBuffer', 48), Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer$BufferUsage_2_classLit = createForEnum('com.github.rma350.jgraphv.core.shapes.', 'NativeShapeBuffer$BufferUsage', 63, values_0), _3Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer$BufferUsage_2_classLit = createForArray('[Lcom.github.rma350.jgraphv.core.shapes.', 'NativeShapeBuffer$BufferUsage;', 256, Lcom_github_rma350_jgraphv_core_shapes_NativeShapeBuffer$BufferUsage_2_classLit), Lcom_github_rma350_jgraphv_core_shapes_Arcs_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'Arcs', 54), Lcom_github_rma350_jgraphv_core_shapes_PointsBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'PointsBuffer', 66), Lcom_github_rma350_jgraphv_core_shapes_Points_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'Points', 65), Lcom_github_rma350_jgraphv_core_shapes_DirectedArrowBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'DirectedArrowBuffer', 58), Lcom_github_rma350_jgraphv_core_shapes_DirectedLines_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'DirectedLines', 59), Lcom_github_rma350_jgraphv_core_shapes_LinesBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'LinesBuffer', 61), Lcom_github_rma350_jgraphv_core_shapes_Lines_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'Lines', 60), Lcom_github_rma350_jgraphv_core_shapes_CirclesBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'CirclesBuffer', 56), Lcom_github_rma350_jgraphv_core_shapes_Circles_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'Circles', 55), Lcom_github_rma350_jgraphv_core_shapes_TriangleBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.core.shapes.', 'TriangleBuffer', 69), Lcom_github_rma350_jgraphv_core_graph_typed_Node_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.typed.', 'Node', 42), Lcom_github_rma350_jgraphv_core_graph_structures_DirectedGraph_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'DirectedGraph', 34), Lcom_github_rma350_jgraphv_core_graph_rendering_GraphView_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'GraphView', 32), _3Lcom_github_rma350_jgraphv_core_graph_typed_Node_2_classLit = createForArray('[Lcom.github.rma350.jgraphv.core.graph.typed.', 'Node;', 257, Lcom_github_rma350_jgraphv_core_graph_typed_Node_2_classLit), Lcom_github_rma350_jgraphv_core_graph_structures_UndirectedGraph_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'UndirectedGraph', 37), Lcom_github_rma350_jgraphv_core_graph_typed_LayoutInput_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.typed.', 'LayoutInput', 41), Lcom_github_rma350_jgraphv_core_graph_layout_SpringLayout_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.layout.', 'SpringLayout', 24), Lcom_github_rma350_jgraphv_core_graph_rendering_AnimatedGraphLayout_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'AnimatedGraphLayout', 27), Lcom_github_rma350_jgraphv_core_graph_rendering_AnimatedGraphLayout$1_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'AnimatedGraphLayout$1', 28), Lcom_google_gwt_user_client_ui_UIObject_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'UIObject', 175), Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'Widget', 174), Lcom_google_gwt_user_client_ui_LabelBase_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'LabelBase', 173), Lcom_google_gwt_user_client_ui_Label_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'Label', 172), Lcom_google_gwt_user_client_ui_HTML_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'HTML', 171), Lcom_google_gwt_i18n_client_HasDirection$Direction_2_classLit = createForEnum('com.google.gwt.i18n.client.', 'HasDirection$Direction', 123, values_2), _3Lcom_google_gwt_i18n_client_HasDirection$Direction_2_classLit = createForArray('[Lcom.google.gwt.i18n.client.', 'HasDirection$Direction;', 258, Lcom_google_gwt_i18n_client_HasDirection$Direction_2_classLit), Ljava_util_NoSuchElementException_2_classLit = createForClass('java.util.', 'NoSuchElementException', 229), Ljava_lang_IllegalStateException_2_classLit = createForClass('java.lang.', 'IllegalStateException', 187), Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass('java.lang.', 'IndexOutOfBoundsException', 188), Ljava_util_MapEntryImpl_2_classLit = createForClass('java.util.', 'MapEntryImpl', 228), Lcom_github_rma350_jgraphv_core_portable_impl_JVec2_2_classLit = createForClass('com.github.rma350.jgraphv.core.portable.impl.', 'JVec2', 45), Lcom_github_rma350_jgraphv_core_graph_typed_Edge_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.typed.', 'Edge', 40), Lcom_github_rma350_jgraphv_core_graph_rendering_NodeCircleView_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'NodeCircleView', 33), Lcom_github_rma350_jgraphv_core_graph_rendering_EdgeArrowView_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'EdgeArrowView', 30), Lcom_github_rma350_jgraphv_core_graph_rendering_EdgeLineView_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'EdgeLineView', 31), Lcom_github_rma350_jgraphv_core_graph_structures_UndirectedMatrixAdjacency_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'UndirectedMatrixAdjacency', 39), Lcom_github_rma350_jgraphv_core_graph_layout_NodePositions_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.layout.', 'NodePositions', 22), Lcom_github_rma350_jgraphv_core_graph_layout_NodePositions$NodeData_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.layout.', 'NodePositions$NodeData', 23), Lcom_github_rma350_jgraphv_core_graph_rendering_EdgeArcView_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.rendering.', 'EdgeArcView', 29), Ljava_util_Collections$UnmodifiableCollection_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableCollection', 215), Ljava_util_Collections$UnmodifiableList_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableList', 217), Ljava_util_Collections$UnmodifiableMap_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableMap', 218), Ljava_util_Collections$UnmodifiableSet_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableSet', 220), Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableMap$UnmodifiableEntrySet', 219), Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry', 222), Ljava_util_Collections$UnmodifiableRandomAccessList_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableRandomAccessList', 223), Ljava_util_Collections$UnmodifiableCollectionIterator_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableCollectionIterator', 216), Ljava_util_Collections$UnmodifiableMap$UnmodifiableEntrySet$1_2_classLit = createForClass('java.util.', 'Collections$UnmodifiableMap$UnmodifiableEntrySet$1', 221), Lcom_github_rma350_jgraphv_core_graph_structures_DirectedHashAdjacency_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'DirectedHashAdjacency', 35), Lcom_github_rma350_jgraphv_core_graph_structures_UndirectedHashAdjacency_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'UndirectedHashAdjacency', 38), Lcom_google_gwt_user_client_ui_DirectionalTextHelper_2_classLit = createForClass('com.google.gwt.user.client.ui.', 'DirectionalTextHelper', 170), Lcom_google_gwt_dom_client_Style$TextAlign_2_classLit = createForEnum('com.google.gwt.dom.client.', 'Style$TextAlign', 112, values_1), _3Lcom_google_gwt_dom_client_Style$TextAlign_2_classLit = createForArray('[Lcom.google.gwt.dom.client.', 'Style$TextAlign;', 259, Lcom_google_gwt_dom_client_Style$TextAlign_2_classLit), Lcom_google_gwt_dom_client_Style$TextAlign$1_2_classLit = createForEnum('com.google.gwt.dom.client.', 'Style$TextAlign$1', 113, null), Lcom_google_gwt_dom_client_Style$TextAlign$2_2_classLit = createForEnum('com.google.gwt.dom.client.', 'Style$TextAlign$2', 114, null), Lcom_google_gwt_dom_client_Style$TextAlign$3_2_classLit = createForEnum('com.google.gwt.dom.client.', 'Style$TextAlign$3', 115, null), Lcom_google_gwt_dom_client_Style$TextAlign$4_2_classLit = createForEnum('com.google.gwt.dom.client.', 'Style$TextAlign$4', 116, null), Lcom_github_rma350_jgraphv_web_client_coredeps_WebNativeFloatBuffer_2_classLit = createForClass('com.github.rma350.jgraphv.web.client.coredeps.', 'WebNativeFloatBuffer', 81), Lcom_github_rma350_jgraphv_core_graph_structures_InternalEdge_2_classLit = createForClass('com.github.rma350.jgraphv.core.graph.structures.', 'InternalEdge', 36);\n$sendStats('moduleStartup', 'moduleEvalEnd');\ngwtOnLoad(__gwtModuleFunction.__errFn, __gwtModuleFunction.__moduleName, __gwtModuleFunction.__moduleBase, __gwtModuleFunction.__softPermutationId,__gwtModuleFunction.__computePropValue);\n$sendStats('moduleStartup', 'end');\n//# sourceURL=jgraphvweb-0.js\n"]);
